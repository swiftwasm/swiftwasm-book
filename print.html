<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Swift and WebAssembly</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="getting-started/index.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="getting-started/setup.html"><strong aria-hidden="true">2.1.</strong> Setup</a></li><li class="chapter-item expanded "><a href="getting-started/hello-world.html"><strong aria-hidden="true">2.2.</strong> Hello, World</a></li><li class="chapter-item expanded "><a href="getting-started/swift-package.html"><strong aria-hidden="true">2.3.</strong> Use Swift Package Manager</a></li><li class="chapter-item expanded "><a href="getting-started/browser-app.html"><strong aria-hidden="true">2.4.</strong> Creating a browser app</a></li><li class="chapter-item expanded "><a href="getting-started/javascript-interop.html"><strong aria-hidden="true">2.5.</strong> JavaScript interoperation</a></li><li class="chapter-item expanded "><a href="getting-started/foundation.html"><strong aria-hidden="true">2.6.</strong> Swift Foundation</a></li></ol></li><li class="chapter-item expanded "><a href="examples/index.html"><strong aria-hidden="true">3.</strong> Examples</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="examples/importing-function.html"><strong aria-hidden="true">3.1.</strong> Importing function</a></li><li class="chapter-item expanded "><a href="examples/exporting-function.html"><strong aria-hidden="true">3.2.</strong> Exporting function</a></li><li class="chapter-item expanded "><a href="examples/example-projects.html"><strong aria-hidden="true">3.3.</strong> Example projects</a></li></ol></li><li class="chapter-item expanded "><a href="contribution-guide/index.html"><strong aria-hidden="true">4.</strong> Contribution Guide</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="contribution-guide/how-to-build-toolchain.html"><strong aria-hidden="true">4.1.</strong> How to build the toolchain</a></li><li class="chapter-item expanded "><a href="contribution-guide/tips.html"><strong aria-hidden="true">4.2.</strong> Tips</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Swift and WebAssembly</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>Welcome to the SwiftWasm Documentation!</p>
<p><a href="https://github.com/swiftwasm">SwiftWasm is an open source project to support the WebAssembly target for Swift.</a></p>
<p>The goal of this project is to fully support the WebAssembly target for <a href="https://swift.org">Swift</a> and to be merged into <a href="https://github.com/apple/swift">the upstream repository</a>.</p>
<p>WebAssembly is described on its <a href="https://webassembly.org/">home page</a> as:</p>
<blockquote>
<p>WebAssembly (abbreviated as Wasm) is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications.</p>
</blockquote>
<p>We use LLVM as a compiler backend to produce WebAssembly binaries. Our resulting binaries also depend on <a href="https://wasi.dev">WASI</a>, which is a modular system interface for WebAssembly. WASI is mainly required to compile Swift Standard Library.</p>
<h1><a class="header" href="#getting-started" id="getting-started">Getting Started</a></h1>
<p>This is a getting started guide section to use SwiftWasm.</p>
<p>You can learn about:</p>
<ul>
<li>How to set up a Swift toolchain for compiling to WebAssembly</li>
<li>How to compile a simple Swift code and Swift Package into WebAssembly</li>
<li>How to interoperate with JavaScript</li>
</ul>
<h1><a class="header" href="#installation" id="installation">Installation</a></h1>
<p>You can install latest toolchain of SwiftWasm from <a href="https://github.com/swiftwasm/swift/releases">Release Page</a></p>
<p>The toolchains can be installed via <a href="https://github.com/kylef/swiftenv"><code>swiftenv</code></a> like <a href="https://swift.org/download/#snapshots">official nightly snapshot</a>.</p>
<p>Here's an example <code>swiftenv</code> invocation for installing the latest stable SwiftWasm toolchain on macOS Catalina:</p>
<pre><code class="language-sh">
$ swiftenv install \
  https://github.com/swiftwasm/swift/releases/download/swift-wasm-5.3-SNAPSHOT-2020-10-02-a/swift-wasm-5.3-SNAPSHOT-2020-10-02-a-osx.tar.gz
$ swift --version
Swift version 5.3-dev (LLVM ba56ef042e, Swift 5855a96018)
Target: x86_64-apple-darwin19.3.0
</code></pre>
<h1><a class="header" href="#hello-world" id="hello-world">Hello, World!</a></h1>
<p>This section will show you how to compile a simple Swift code into WebAssembly and run the produced binary on WASI supported WebAssembly runtime.</p>
<h2><a class="header" href="#1-create-a-swift-file" id="1-create-a-swift-file">1. Create a Swift file</a></h2>
<pre><code class="language-sh">$ echo 'print(&quot;Hello, world!&quot;)' &gt; hello.swift
</code></pre>
<h2><a class="header" href="#2-compile-swift-code-into-webassembly-with-wasi" id="2-compile-swift-code-into-webassembly-with-wasi">2. Compile Swift code into WebAssembly with WASI</a></h2>
<pre><code>$ TOOLCHAIN_PATH=$(dirname $(swiftenv which swiftc))/../
$ swiftc \
    -target wasm32-unknown-wasi \
    -sdk $TOOLCHAIN_PATH/share/wasi-sysroot \
    hello.swift -o hello.wasm
</code></pre>
<h2><a class="header" href="#3-run-the-produced-binary-on-webassembly-runtime" id="3-run-the-produced-binary-on-webassembly-runtime">3. Run the produced binary on WebAssembly runtime</a></h2>
<p>You can the run the produced binary with <a href="https://wasmer.io/">wasmer</a> (or other WebAssembly runtime):</p>
<pre><code class="language-sh">$ wasmer hello.wasm
</code></pre>
<p>The produced binary depends on WASI which is an interface of system call for WebAssembly.
So you need to use WASI supported runtime and when you run the binary on browser, you need WASI polyfill library like <a href="https://github.com/wasmerio/wasmer-js/tree/master/packages/wasi">@wasmer/wasi</a>.</p>
<h1><a class="header" href="#compile-a-swiftpm-package-to-webassembly" id="compile-a-swiftpm-package-to-webassembly">Compile a SwiftPM package to WebAssembly</a></h1>
<p>You can also use SwiftPM for managing packages in the same way as other platforms.</p>
<h2><a class="header" href="#1-create-a-package-from-template" id="1-create-a-package-from-template">1. Create a package from template</a></h2>
<pre><code class="language-sh">$ swift package init --type executable
Creating executable package: hello
Creating Package.swift
Creating README.md
Creating .gitignore
Creating Sources/
Creating Sources/hello/main.swift
Creating Tests/
Creating Tests/LinuxMain.swift
Creating Tests/helloTests/
Creating Tests/helloTests/helloTests.swift
Creating Tests/helloTests/XCTestManifests.swift
</code></pre>
<h2><a class="header" href="#2-build-the-project-into-a-webassembly-binary" id="2-build-the-project-into-a-webassembly-binary">2. Build the Project into a WebAssembly binary</a></h2>
<p>You need to pass <code>--triple</code> option, which indicates that you are building for the target.</p>
<pre><code class="language-sh">$ swift build --triple wasm32-unknown-wasi
</code></pre>
<h2><a class="header" href="#3-run-the-produced-binary" id="3-run-the-produced-binary">3. Run the produced binary</a></h2>
<p>Just as in the <a href="getting-started/./hello-world.html">previous section</a>, you can run the produced binary with the <code>wasmer</code> WebAssembly runtime.</p>
<pre><code class="language-sh">$ wasmer ./.build/debug/hello-swiftwasm
Hello, world!
</code></pre>
<h1><a class="header" href="#creating-a-browser-app" id="creating-a-browser-app">Creating a Browser App</a></h1>
<p>Currently, <a href="https://tokamak.dev">the Tokamak UI framework</a> is one of the easiest ways to build a
browser app with SwiftWasm. It tries to be compatible with <a href="https://developer.apple.com/xcode/swiftui/">the SwiftUI
API</a> as much as possible, which potentially allows
you to share most if not all code between SwiftWasm and other platforms.</p>
<h2><a class="header" href="#requirements" id="requirements">Requirements</a></h2>
<p>Tokamak relies on <a href="https://carton.dev">the <code>carton</code> development tool</a> for development and testing.
While you can build Tokamak apps without <code>carton</code>, that would require a lot of manual steps that are
already automated with <code>carton</code>.</p>
<h3><a class="header" href="#system-requirements" id="system-requirements">System Requirements</a></h3>
<ul>
<li>macOS 10.15 and Xcode 11.4 or later.</li>
<li><a href="https://swift.org/download/">Swift 5.2 or later</a> and Ubuntu 18.04 for Linux users.</li>
</ul>
<h3><a class="header" href="#installation-1" id="installation-1">Installation</a></h3>
<p>On macOS <code>carton</code> can be installed with <a href="https://brew.sh/">Homebrew</a>. Make sure you have Homebrew
installed and then run:</p>
<pre><code class="language-sh">brew install swiftwasm/tap/carton
</code></pre>
<p>You'll have to build <code>carton</code> from sources on Linux. Clone the repository and run
<code>swift build -c release</code>, the <code>carton</code> binary will be located in the <code>.build/release</code>
directory after that.
Assuming you already have Homebrew installed, you can create a new Tokamak
app by following these steps:</p>
<ol>
<li>Install <code>carton</code>:</li>
</ol>
<pre><code>brew install swiftwasm/tap/carton
</code></pre>
<p>If you had <code>carton</code> installed before this, make sure you have version 0.6.1 or greater:</p>
<pre><code>carton --version
</code></pre>
<ol start="2">
<li>Create a directory for your project and make it current:</li>
</ol>
<pre><code>mkdir TokamakApp &amp;&amp; cd TokamakApp
</code></pre>
<ol start="3">
<li>Initialize the project from a template with <code>carton</code>:</li>
</ol>
<pre><code>carton init --template tokamak
</code></pre>
<ol start="4">
<li>Build the project and start the development server, <code>carton dev</code> can be kept running
during development:</li>
</ol>
<pre><code>carton dev
</code></pre>
<ol start="5">
<li>Open <a href="http://127.0.0.1:8080/">http://127.0.0.1:8080/</a> in your browser to see the app
running. You can edit the app source code in your favorite editor and save it, <code>carton</code>
will immediately rebuild the app and reload all browser tabs that have the app open.</li>
</ol>
<p>You can also clone <a href="https://github.com/TokamakUI/Tokamak">the Tokamak repository</a> and run <code>carton dev</code> in its root directory. This will build the demo app that shows almost all of the currently
implemented APIs.</p>
<h1><a class="header" href="#javascript-interoperation" id="javascript-interoperation">JavaScript interoperation</a></h1>
<p><a href="https://github.com/swiftwasm/JavaScriptKit">JavaScriptKit</a> is a Swift framework to interact with JavaScript through WebAssembly.</p>
<p>You can use any JavaScript API from Swift with this library. Here's a quick example of JavaScriptKit
usage in a browser app:</p>
<pre><code class="language-swift">import JavaScriptKit

let document = JSObject.global.document

var divElement = document.createElement(&quot;div&quot;)
divElement.innerText = &quot;Hello, world&quot;
_ = document.body.appendChild(divElement)
</code></pre>
<p>You can also use JavaScriptKit in SwiftWasm apps integrated with Node.js, as there no assumptions
that any browser API is present in the library.</p>
<p>JavaScriptKit consists of a runtime library package <a href="https://www.npmjs.com/package/javascript-kit-swift">hosted on
npm</a>, and a SwiftPM package for the API on the
Swift side. To integrate the JavaScript runtime automatically into your app, we recommend following
the corresponding <a href="getting-started/./browser-app.html">guide for browser apps in our book</a>.</p>
<h1><a class="header" href="#use-swift-foundation-in-your-code" id="use-swift-foundation-in-your-code">Use Swift Foundation in your code</a></h1>
<p><a href="https://swift.org/core-libraries/#foundation">The Foundation core library</a> is available in
SwiftWasm, but in a limited capacity. The main reason is that <a href="https://swift.org/core-libraries/#libdispatch">the Dispatch core
library</a> is unavailable due to <a href="https://github.com/swiftwasm/swift/issues/1887">the lack of 
standardized multi-threading support</a> in WebAssembly
and SwiftWasm itself. Many Foundation APIs rely on the presence of Dispatch under the hood,
specifically file system access and threading helpers. A few other types are unavailable in browsers
or aren't standardized in WASI hosts, such as support for sockets and low-level networking, or
support for time zone files, and they had to be disabled. These types are therefore absent in
SwiftWasm Foundation:</p>
<ul>
<li><code>FileManager</code></li>
<li><code>Host</code></li>
<li><code>Notification</code></li>
<li><code>NotificationQueue</code></li>
<li><code>NSKeyedArchiver</code></li>
<li><code>NSKeyedArchiverHelpers</code></li>
<li><code>NSKeyedCoderOldStyleArray</code></li>
<li><code>NSKeyedUnarchiver</code></li>
<li><code>NSNotification</code></li>
<li><code>NSSpecialValue</code></li>
<li><code>Port</code></li>
<li><code>PortMessage</code></li>
<li><code>Process</code></li>
<li><code>ProcessInfo</code></li>
<li><code>PropertyListEncoder</code></li>
<li><code>RunLoop</code></li>
<li><code>Stream</code></li>
<li><code>Thread</code></li>
<li><code>Timer</code></li>
<li><code>UserDefaults</code></li>
</ul>
<p>Related functions and properties on other types are also absent or disabled. We would like to make
them available in the future as soon as possible, and <a href="getting-started/../contribution-guide/index.html">we invite you to 
contribute</a> and help us in achieving this goal!</p>
<h1><a class="header" href="#examples" id="examples">Examples</a></h1>
<p>This section shows you example usage of our toolchain.</p>
<h1><a class="header" href="#importing-a-function-from-host-environments" id="importing-a-function-from-host-environments">Importing a function from host environments</a></h1>
<p>You can import a function from your host environment using the integration of Swift Package Manager
with C targets. Firstly, you should declare a signature for your function in a C header with an
appropriate <code>__import_name__</code> attribute:</p>
<pre><code class="language-c">__attribute__((__import_name__(&quot;add&quot;)))
extern int add(int lhs, int rhs);
</code></pre>
<p>Here <code>__import_name__</code> specifies the name under which this function will be exposed to Swift code.
Move this C header to a separate target, we'll call it <code>HostFunction</code> in this example. Your
<code>Package.swift</code> manifest for your WebAssembly app would look like this:</p>
<pre><code class="language-swift">// swift-tools-version:5.3
// The swift-tools-version declares the minimum version of Swift required to build this package.
import PackageDescription

let package = Package(
    name: &quot;SwiftWasmApp&quot;,
    targets: [
      .target(name: &quot;HostFunction&quot;, dependencies: []),
      .target(name: &quot;SwiftWasmApp&quot;, dependencies: [&quot;HostFunction&quot;]),
    ]
)
</code></pre>
<p>Place this header into the <code>include</code> subdirectory of your <code>HostFunction</code> target directory. You can
then import this host function module into Swift code just as any other module:</p>
<pre><code class="language-swift">import HostFunction

print(add(2, 2))
</code></pre>
<p>Then, you can inject a host function into the produced WebAssembly binary.</p>
<p>Note that we use <code>env</code> as default import module name. You can specify the module name as
<code>__import_module__</code> in your C header. The full list of attributes in the header could look
like <code>__attribute__((__import_module__(&quot;env&quot;),__import_name__(&quot;add&quot;)))</code>.</p>
<pre><code class="language-javascript">const WASI = require(&quot;@wasmer/wasi&quot;).WASI;
const WasmFs = require(&quot;@wasmer/wasmfs&quot;).WasmFs;

const promisify = require(&quot;util&quot;).promisify;
const fs = require(&quot;fs&quot;);
const readFile = promisify(fs.readFile);

const main = async () =&gt; {
  const wasmFs = new WasmFs();
  // Output stdout and stderr to console
  const originalWriteSync = wasmFs.fs.writeSync;
  wasmFs.fs.writeSync = (fd, buffer, offset, length, position) =&gt; {
    const text = new TextDecoder(&quot;utf-8&quot;).decode(buffer);
    switch (fd) {
      case 1:
        console.log(text);
        break;
      case 2:
        console.error(text);
        break;
    }
    return originalWriteSync(fd, buffer, offset, length, position);
  };

  // Instantiate a new WASI Instance
  let wasi = new WASI({
    args: [],
    env: {},
    bindings: {
      ...WASI.defaultBindings,
      fs: wasmFs.fs,
    },
  });

  const wasmBinary = await readFile(&quot;lib.wasm&quot;);

  // Instantiate the WebAssembly file
  let { instance } = await WebAssembly.instantiate(wasmBinary, {
    wasi_snapshot_preview1: wasi.wasiImport,
    env: {
      add: (lhs, rhs) =&gt; (lhs + rhs),
    }
  });

  wasi.start(instance);
};

main()
</code></pre>
<p>If you use Go bindings for Wasmer as your host environment, you should check <a href="https://github.com/hassan-shahbazi/swiftwasm-go">an example 
repository</a> from one of our contributors that shows
an integration with an imported host function.</p>
<p>A more streamlined way to import host functions will be implemented in the future version of the
SwiftWasm toolchain.</p>
<h1><a class="header" href="#exporting-function-for-host-environment" id="exporting-function-for-host-environment">Exporting function for host environment</a></h1>
<p>You can expose a Swift function for host environment using special attribute and linker option.</p>
<pre><code class="language-swift">@_cdecl(&quot;add&quot;)
func add(_ lhs: Int, _ rhs: Int) -&gt; Int {
    return lhs + rhs
}
</code></pre>
<p>You need to compile the Swift code with linker option <code>--export</code>.</p>
<pre><code class="language-bash">$ TOOLCHAIN_PATH=$(dirname $(swiftenv which swiftc))/../
$ swiftc \
    -target wasm32-unknown-wasi \
    -sdk $TOOLCHAIN_PATH/share/wasi-sysroot \
    lib.swift -o lib.wasm \
    -Xlinker --export=add
</code></pre>
<p>Then, you can use the exported function from host environment.</p>
<pre><code class="language-javascript">const WASI = require(&quot;@wasmer/wasi&quot;).WASI;
const WasmFs = require(&quot;@wasmer/wasmfs&quot;).WasmFs;

const promisify = require(&quot;util&quot;).promisify;
const fs = require(&quot;fs&quot;);
const readFile = promisify(fs.readFile);

const main = async () =&gt; {
  // Instantiate a new WASI Instance
  const wasmFs = new WasmFs();
  let wasi = new WASI({
    args: [],
    env: {},
    bindings: {
      ...WASI.defaultBindings,
      fs: wasmFs.fs,
    },
  });

  const wasmBinary = await readFile(&quot;lib.wasm&quot;);

  // Instantiate the WebAssembly file
  let { instance } = await WebAssembly.instantiate(wasmBinary, {
    wasi_snapshot_preview1: wasi.wasiImport,
  });
  // Get the exported function
  const addFn = instance.exports.add;
  console.log(&quot;2 + 3 = &quot; + addFn(2, 3))

};

main()
</code></pre>
<p>If you use SwiftPM package, you can omit linker flag using clang's <code>__atribute__</code>. Please see <a href="https://github.com/swiftwasm/JavaScriptKit/pull/91/files">swiftwasm/JavaScriptKit#91</a> for more detail info</p>
<h2><a class="header" href="#example-projects" id="example-projects">Example Projects</a></h2>
<p>You can learn more practical usage of our toolchain in <a href="https://github.com/swiftwasm/awesome-swiftwasm">swiftwasm/awesome-swiftwasm</a></p>
<h1><a class="header" href="#contribution-guide" id="contribution-guide">Contribution Guide</a></h1>
<h2><a class="header" href="#forum-posts" id="forum-posts">Forum posts</a></h2>
<ul>
<li><a href="https://forums.swift.org/t/wasm-support/16087/14">Design of this project</a></li>
<li><a href="https://forums.swift.org/t/webassembly-swiftpm/34343">Swift Package Manager Support</a></li>
</ul>
<h2><a class="header" href="#repositories" id="repositories">Repositories</a></h2>
<h3><a class="header" href="#a-hrefhttpsgithubcomswiftwasmswiftswiftwasmswifta" id="a-hrefhttpsgithubcomswiftwasmswiftswiftwasmswifta"><a href="https://github.com/swiftwasm/swift">swiftwasm/swift</a></a></h3>
<p>The main repository of this project. Forked from <a href="https://github.com/swiftwasm/swift">apple/swift</a>. We are tracking upstream changes using <a href="https://github.com/wei/pull">pull</a></p>
<h4><a class="header" href="#branching-scheme" id="branching-scheme">Branching scheme</a></h4>
<ul>
<li><code>swiftwasm</code> is the main development branch.</li>
<li><code>main</code> is a mirror of the <code>main</code> branch of the upstream <code>apple/swift</code> repository. This branch is necessary to avoid <a href="https://github.com/swiftwasm/swift/pull/36">some issues</a>.</li>
<li><code>swiftwasm-release/5.3</code> is the branch where 5.3 release of SwiftWasm is prepared.</li>
<li><code>release/5.3</code> is a mirror of the upstream <code>release/5.3</code> branch.</li>
</ul>
<h3><a class="header" href="#a-hrefhttpsgithubcomswiftwasmllvm-projectswiftwasmllvm-projecta" id="a-hrefhttpsgithubcomswiftwasmllvm-projectswiftwasmllvm-projecta"><a href="https://github.com/swiftwasm/llvm-project">swiftwasm/llvm-project</a></a></h3>
<p>This repository is a fork of <a href="https://github.com/apple/llvm-project">apple/llvm-project</a>.</p>
<p><code>swiftwasm</code> branch is based on <code>swift/main</code> branch of <code>apple/llvm-project</code>.</p>
<p>Please see the <a href="https://github.com/apple/llvm-project/blob/apple/main/apple-docs/AppleBranchingScheme.md">AppleBranchingScheme.md</a>
document in the upstream repository for more details.</p>
<h3><a class="header" href="#a-hrefhttpsgithubcomswiftwasmicu4c-wasiswiftwasmicu4c-wasia" id="a-hrefhttpsgithubcomswiftwasmicu4c-wasiswiftwasmicu4c-wasia"><a href="https://github.com/swiftwasm/icu4c-wasi">swiftwasm/icu4c-wasi</a></a></h3>
<p>Build script and patches for building ICU project for WebAssembly. <a href="https://github.com/unicode-org/icu/pull/990">The required changes to build 
it</a> were merged to the upstream repository.</p>
<h3><a class="header" href="#a-hrefhttpsgithubcomswiftwasmwasi-sdkswiftwasmwasi-sdka-and-a-hrefhttpsgithubcomswiftwasmwasi-libcswiftwasmwasi-libca" id="a-hrefhttpsgithubcomswiftwasmwasi-sdkswiftwasmwasi-sdka-and-a-hrefhttpsgithubcomswiftwasmwasi-libcswiftwasmwasi-libca"><a href="https://github.com/swiftwasm/wasi-sdk">swiftwasm/wasi-sdk</a> and <a href="https://github.com/swiftwasm/wasi-libc">swiftwasm/wasi-libc</a></a></h3>
<p>Forked from <a href="https://github.com/WebAssembly/wasi-sdk">WebAssembly/wasi-sdk</a> and <a href="https://github.com/WebAssembly/wasi-libc">WebAssembly/wasi-libc</a>.</p>
<p>We fork them to build <code>wasi-sysroot</code> with pthread header. There aren't so many diff from upstream.</p>
<h1><a class="header" href="#how-to-build-toolchain" id="how-to-build-toolchain">How to build toolchain</a></h1>
<h2><a class="header" href="#1-checkout-the-project-source-code" id="1-checkout-the-project-source-code">1. Checkout the project source code.</a></h2>
<pre><code class="language-sh">$ mkdir swiftwasm-source
$ cd swiftwasm-source
$ git clone https://github.com/swiftwasm/swift.git
$ ./swift/utils/update-checkout --scheme wasm --clone
</code></pre>
<h2><a class="header" href="#2-install-required-dependencies" id="2-install-required-dependencies">2. Install required dependencies</a></h2>
<p>Before building Swift, please install required dependencies.</p>
<pre><code class="language-sh"># On macOS
$ brew install cmake ninja llvm sccache wasmer
$ ./utils/webassembly/macos/install-dependencies.sh
# On Linux
$ ./utils/webassembly/linux/install-dependencies.sh
</code></pre>
<h2><a class="header" href="#3-build-using-custom-preset-options" id="3-build-using-custom-preset-options">3. Build using custom preset options</a></h2>
<p>We support both Linux and macOS to build Swift. You need to select the preset name, <code>sccache</code> path and LLVM tools directory.</p>
<pre><code class="language-sh"># On macOS
$ ./utils/build-script \
        --preset=webassembly-macos-target \
        --preset-file ./utils/webassembly/build-presets.ini  \
        SOURCE_PATH=$(dirname $(pwd)) \
        LLVM_BIN_DIR=/usr/local/opt/llvm/bin \
        C_CXX_LAUNCHER=$(which sccache)
# On Linux
$ ./utils/build-script \
        --preset=webassembly-linux-target \
        --preset-file ./utils/webassembly/build-presets.ini  \
        SOURCE_PATH=$(dirname $(pwd)) \
        LLVM_BIN_DIR=/usr/local/opt/llvm/bin \
        C_CXX_LAUNCHER=$(which sccache)
</code></pre>
<p>Or if you want to build whole toolchain, please use <code>./utils/webassembly/build-toolchain.sh</code>. This script builds compiler, Swift Standard Library for host environment (e.g. macOS or Linux) and target environment (<code>wasm32-unknown-wasi</code>), Foundation and other packages. So it takes longer time than the above script.</p>
<pre><code class="language-bash">$ ./utils/webassembly/build-toolchain.sh
</code></pre>
<p>If you want to get more information about build system, please feel free to ask @kateinoigakukun on Twitter or GitHub.</p>
<h2><a class="header" href="#continuous-integration" id="continuous-integration">Continuous Integration</a></h2>
<p>We use GitHub Actions to build and run tests continuously.
(But jobs without cache takes 2~3 hours to be completed)</p>
<p>Currently (2020/10/4), we only run stdlib tests on Linux CI because the job execution time and storage reached GitHub Actions limits.</p>
<p>References:</p>
<ul>
<li><a href="https://github.com/swiftwasm/swift/pull/160#issuecomment-586537014">swiftwasm/swift#160</a></li>
<li><a href="https://github.com/swiftwasm/swift/pull/232">swiftwasm/swift#232</a></li>
</ul>
<h3><a class="header" href="#nightly-distribution" id="nightly-distribution">Nightly distribution</a></h3>
<p>We distribute latest <code>swiftwasm</code> branch and <code>swiftwasm-release/5.3</code> branch toolchains at UTC 00:00 everyday. You can check the latest toolchain at <a href="https://github.com/swiftwasm/swift/releases">GitHub Release Page</a></p>
<h2><a class="header" href="#cache" id="cache">Cache</a></h2>
<p>Compilation time of LLVM and the Swift toolchain is very long, so we recommend to cache the artifacts using <code>sccache</code>. <a href="https://github.com/apple/swift/blob/main/docs/HowToGuides/GettingStarted.md#the-roles-of-different-tools">The &quot;Getting started&quot; guide</a> from the upstream toolchain provides more details about the use of <code>sccache</code>.</p>
<h3><a class="header" href="#references" id="references">References</a></h3>
<ul>
<li><a href="https://github.com/mozilla/sccache">mozilla/sccache</a></li>
<li><a href="https://github.com/apple/swift/blob/master/docs/DevelopmentTips.md#use-sccache-to-cache-build-artifacts">Use sccache to cache build artifacts</a></li>
</ul>
<h2><a class="header" href="#debugging" id="debugging">Debugging</a></h2>
<p>When you want to debug a WebAssembly binary, <a href="https://github.com/kateinoigakukun/wasminspect">wasminspect</a> 
can help in the investigation if the debugged binary does not rely on integration with JavaScript.
We recommend splitting your packages into separate executable targets, most of which shouldn't 
assume the availability of JavaScript to make debugging easier.</p>
<p><img src="https://raw.githubusercontent.com/kateinoigakukun/wasminspect/master/assets/demo.gif" alt="demo" /></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
