<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Swift and WebAssembly</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="getting-started/index.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="getting-started/setup.html"><strong aria-hidden="true">2.1.</strong> Setup</a></li><li class="chapter-item expanded "><a href="getting-started/hello-world.html"><strong aria-hidden="true">2.2.</strong> Hello, World</a></li><li class="chapter-item expanded "><a href="getting-started/swift-package.html"><strong aria-hidden="true">2.3.</strong> Using Swift Package Manager</a></li><li class="chapter-item expanded "><a href="getting-started/porting.html"><strong aria-hidden="true">2.4.</strong> Porting code from other platforms</a></li><li class="chapter-item expanded "><a href="getting-started/browser-app.html"><strong aria-hidden="true">2.5.</strong> Creating a browser app</a></li><li class="chapter-item expanded "><a href="getting-started/javascript-interop.html"><strong aria-hidden="true">2.6.</strong> JavaScript interoperation</a></li><li class="chapter-item expanded "><a href="getting-started/testing.html"><strong aria-hidden="true">2.7.</strong> Testing your app</a></li></ol></li><li class="chapter-item expanded "><a href="examples/index.html"><strong aria-hidden="true">3.</strong> Examples</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="examples/importing-function.html"><strong aria-hidden="true">3.1.</strong> Importing function</a></li><li class="chapter-item expanded "><a href="examples/exporting-function.html"><strong aria-hidden="true">3.2.</strong> Exporting function</a></li><li class="chapter-item expanded "><a href="examples/example-projects.html"><strong aria-hidden="true">3.3.</strong> Example projects</a></li></ol></li><li class="chapter-item expanded "><a href="contribution-guide/index.html"><strong aria-hidden="true">4.</strong> Contribution Guide</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="contribution-guide/how-to-build-toolchain.html"><strong aria-hidden="true">4.1.</strong> How to build the toolchain</a></li><li class="chapter-item expanded "><a href="contribution-guide/tips.html"><strong aria-hidden="true">4.2.</strong> Tips</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Swift and WebAssembly</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>Welcome to the SwiftWasm Documentation!</p>
<p><a href="https://github.com/swiftwasm">SwiftWasm is an open source project to support the WebAssembly target for Swift.</a></p>
<p>The goal of this project is to fully support the WebAssembly target for <a href="https://swift.org">Swift</a> and to be merged into <a href="https://github.com/apple/swift">the upstream repository</a>.</p>
<p>WebAssembly is described on its <a href="https://webassembly.org/">home page</a> as:</p>
<blockquote>
<p>WebAssembly (abbreviated as Wasm) is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications.</p>
</blockquote>
<p>We use LLVM as a compiler backend to produce WebAssembly binaries. Our resulting binaries also depend on <a href="https://wasi.dev">WASI</a>, which is a modular system interface for WebAssembly. WASI is mainly required to compile Swift Standard Library.</p>
<h1><a class="header" href="#getting-started" id="getting-started">Getting Started</a></h1>
<p>This is a getting started guide section to use SwiftWasm.</p>
<p>You can learn about:</p>
<ul>
<li>How to set up a Swift toolchain for compiling to WebAssembly</li>
<li>How to compile a simple Swift code and Swift Package into WebAssembly</li>
<li>How to interoperate with JavaScript</li>
</ul>
<h1><a class="header" href="#installation" id="installation">Installation</a></h1>
<p>To install Swift for WebAssembly toolchain, download one of the packages below and follow the instructions for your operating system.</p>
<h2><a class="header" href="#releases" id="releases">Releases</a></h2>
<h3><a class="header" href="#swiftwasm-56" id="swiftwasm-56">SwiftWasm 5.6</a></h3>
<p>Tag: <a href="https://github.com/swiftwasm/swift/releases/tag/swift-wasm-5.6.0-RELEASE">swift-wasm-5.6.0-RELEASE</a></p>
<table><thead><tr><th align="center">Download</th><th align="center">Docker Tag</th></tr></thead><tbody>
<tr><td align="center"><a href="https://github.com/swiftwasm/swift/releases/download/swift-wasm-5.6.0-RELEASE/swift-wasm-5.6.0-RELEASE-macos_arm64.pkg">macOS arm64</a></td><td align="center">Unavailable</td></tr>
<tr><td align="center"><a href="https://github.com/swiftwasm/swift/releases/download/swift-wasm-5.6.0-RELEASE/swift-wasm-5.6.0-RELEASE-macos_x86_64.pkg">macOS x86</a></td><td align="center">Unavailable</td></tr>
<tr><td align="center"><a href="https://github.com/swiftwasm/swift/releases/download/swift-wasm-5.6.0-RELEASE/swift-wasm-5.6.0-RELEASE-ubuntu18.04_x86_64.tar.gz">Ubuntu 18.04 x86</a></td><td align="center"><a href="https://github.com/orgs/swiftwasm/packages/container/package/swift">5.6, 5.6-bionic, bionic, latest</a></td></tr>
<tr><td align="center"><a href="https://github.com/swiftwasm/swift/releases/download/swift-wasm-5.6.0-RELEASE/swift-wasm-5.6.0-RELEASE-ubuntu20.04_x86_64.tar.gz">Ubuntu 20.04 x86</a></td><td align="center"><a href="https://github.com/orgs/swiftwasm/packages/container/package/swift">5.6-focal, focal</a></td></tr>
</tbody></table>
<p>You can download the latest development snapshot from <a href="https://github.com/swiftwasm/swift/releases">the Releases page</a></p>
<h1><a class="header" href="#using-downloads" id="using-downloads">Using Downloads</a></h1>
<h2><a class="header" href="#macos" id="macos">macOS</a></h2>
<p>An Xcode toolchain (<code>.xctoolchain</code>) includes a copy of the compiler, linker, and other related tools needed to provide a cohesive development experience for working in a specific version of Swift.</p>
<h3><a class="header" href="#requirements" id="requirements">Requirements</a></h3>
<ul>
<li>macOS 10.15 or later</li>
</ul>
<h3><a class="header" href="#installation-1" id="installation-1">Installation</a></h3>
<ol>
<li><a href="https://book.swiftwasm.org/getting-started/setup.html#swiftwasm-56">Download the latest package release</a> according to your CPU architecture (arm64 for <a href="https://support.apple.com/en-us/HT211814">Apple Silicon Macs</a>, x86 for Intel Macs).</li>
<li>Run the package installer, which will install an Xcode toolchain into <code>/Library/Developer/Toolchains/</code>.</li>
<li>To use the Swift toolchain with command-line tools, use <code>xcrun --toolchain swiftwasm</code> or add the Swift toolchain to your path as follows:</li>
</ol>
<pre><code class="language-bash">export PATH=/Library/Developer/Toolchains/swift-latest.xctoolchain/usr/bin:&quot;${PATH}&quot;
</code></pre>
<ol start="4">
<li>Run <code>swift --version</code>. If you installed the toolchain successfully, you can get the following message.</li>
</ol>
<pre><code class="language-bash">$ swift --version
SwiftWasm Swift version 5.6 (swiftlang-5.6.0)
Target: x86_64-apple-darwin20.6.0
</code></pre>
<blockquote>
<p>Warning: <code>xcrun</code> finds executable binary based on <code>--toolchain</code> option or <code>TOOLCHAINS</code> environment variable, but it also sets <code>SDKROOT</code> as host target SDK (e.g. <code>MacOSX.sdk</code>). So you need to specify <code>-sdk</code> option as <code>/Library/Developer/Toolchains/swift-wasm-5.6.0-RELEASE.xctoolchain/usr/share/wasi-sysroot</code> when launching <code>swiftc</code> from xcrun. <code>swift build</code> or other SwiftPM commands automatically find SDK path based on target triple, so they don't require to specify it.</p>
</blockquote>
<h2><a class="header" href="#linux" id="linux">Linux</a></h2>
<p>Packages for Linux are tar archives including a copy of the Swift compiler, linker, and related tools. You can install them anywhere as long as the extracted tools are in your PATH.</p>
<h3><a class="header" href="#requirements-1" id="requirements-1">Requirements</a></h3>
<ul>
<li>Ubuntu 18.04 or 20.04 (64-bit)</li>
</ul>
<h3><a class="header" href="#installation-2" id="installation-2">Installation</a></h3>
<ol>
<li>Install required dependencies:</li>
</ol>
<pre><code class="language-bash"># Ubuntu 18.04
apt-get install \
          binutils \
          git \
          libc6-dev \
          libcurl4 \
          libedit2 \
          libgcc-5-dev \
          libpython2.7 \
          libsqlite3-0 \
          libstdc++-5-dev \
          libxml2 \
          pkg-config \
          tzdata \
          zlib1g-dev
# Ubuntu 20.04
apt-get install \
          binutils \
          git \
          gnupg2 \
          libc6-dev \
          libcurl4 \
          libedit2 \
          libgcc-9-dev \
          libpython2.7 \
          libsqlite3-0 \
          libstdc++-9-dev \
          libxml2 \
          libz3-dev \
          pkg-config \
          tzdata \
          zlib1g-dev
</code></pre>
<ol start="2">
<li>Download the latest binary release above.</li>
</ol>
<p>The <code>swift-wasm-&lt;VERSION&gt;-&lt;PLATFORM&gt;.tar.gz</code> file is the toolchain itself.</p>
<ol start="3">
<li>Extract the archive with the following command:</li>
</ol>
<pre><code class="language-bash">tar xzf swift-wasm-&lt;VERSION&gt;-&lt;PLATFORM&gt;.tar.gz
</code></pre>
<p>This creates a usr/ directory in the location of the archive.</p>
<ol start="4">
<li>Add the Swift toolchain to your path as follows:</li>
</ol>
<pre><code>export PATH=$(pwd)/usr/bin:&quot;${PATH}&quot;
</code></pre>
<p>You can now execute the swiftc command to build Swift projects.</p>
<h2><a class="header" href="#docker" id="docker">Docker</a></h2>
<p>SwiftWasm offical Docker images are hosted on <a href="https://github.com/orgs/swiftwasm/packages/container/package/swift">GitHub Container Registry</a>.</p>
<p>SwiftWasm Dockerfiles are located on <a href="https://github.com/swiftwasm/swiftwasm-docker">swiftwasm-docker</a> repository.</p>
<h3><a class="header" href="#supported-platforms" id="supported-platforms">Supported Platforms</a></h3>
<ul>
<li>Ubuntu 18.04</li>
<li>Ubuntu 20.04</li>
</ul>
<h3><a class="header" href="#using-docker-images" id="using-docker-images">Using Docker Images</a></h3>
<ol>
<li>Pull the Docker image from <a href="https://github.com/orgs/swiftwasm/packages/container/package/swift">GitHub Container Registry</a>:</li>
</ol>
<pre><code class="language-bash">docker pull ghcr.io/swiftwasm/swift:latest
</code></pre>
<ol start="2">
<li>Create a container using tag <code>latest</code> and attach it to the container:</li>
</ol>
<pre><code class="language-bash">docker run --rm -it ghcr.io/swiftwasm/swift:latest /bin/bash
</code></pre>
<h1><a class="header" href="#hello-world" id="hello-world">Hello, World!</a></h1>
<p>This section will show you how to compile a simple Swift code into WebAssembly and run the produced binary on WASI supported WebAssembly runtime.</p>
<h2><a class="header" href="#1-create-a-swift-file" id="1-create-a-swift-file">1. Create a Swift file</a></h2>
<pre><code class="language-sh">$ echo 'print(&quot;Hello, world!&quot;)' &gt; hello.swift
</code></pre>
<h2><a class="header" href="#2-compile-swift-code-into-webassembly-with-wasi" id="2-compile-swift-code-into-webassembly-with-wasi">2. Compile Swift code into WebAssembly with WASI</a></h2>
<pre><code>$ swiftc -target wasm32-unknown-wasi hello.swift -o hello.wasm
</code></pre>
<h2><a class="header" href="#3-run-the-produced-binary-on-webassembly-runtime" id="3-run-the-produced-binary-on-webassembly-runtime">3. Run the produced binary on WebAssembly runtime</a></h2>
<p>You can the run the produced binary with <a href="https://wasmer.io/">wasmer</a> (or other WebAssembly runtime):</p>
<pre><code class="language-sh">$ wasmer hello.wasm
</code></pre>
<p>The produced binary depends on WASI which is an interface of system call for WebAssembly.
So you need to use WASI supported runtime and when you run the binary on browser, you need WASI polyfill library like <a href="https://github.com/wasmerio/wasmer-js/tree/master/packages/wasi">@wasmer/wasi</a>.</p>
<h1><a class="header" href="#compile-a-swiftpm-package-to-webassembly" id="compile-a-swiftpm-package-to-webassembly">Compile a SwiftPM package to WebAssembly</a></h1>
<p>You can also use SwiftPM for managing packages in the same way as other platforms.</p>
<h2><a class="header" href="#1-create-a-package-from-template" id="1-create-a-package-from-template">1. Create a package from template</a></h2>
<pre><code class="language-sh">$ swift package init --type executable
Creating executable package: hello
Creating Package.swift
Creating README.md
Creating .gitignore
Creating Sources/
Creating Sources/hello/main.swift
Creating Tests/
Creating Tests/LinuxMain.swift
Creating Tests/helloTests/
Creating Tests/helloTests/helloTests.swift
Creating Tests/helloTests/XCTestManifests.swift
</code></pre>
<h2><a class="header" href="#2-build-the-project-into-a-webassembly-binary" id="2-build-the-project-into-a-webassembly-binary">2. Build the Project into a WebAssembly binary</a></h2>
<p>You need to pass <code>--triple</code> option, which indicates that you are building for the target.</p>
<pre><code class="language-sh">$ swift build --triple wasm32-unknown-wasi
</code></pre>
<h2><a class="header" href="#3-run-the-produced-binary" id="3-run-the-produced-binary">3. Run the produced binary</a></h2>
<p>Just as in the <a href="getting-started/./hello-world.html">previous section</a>, you can run the produced binary with the <code>wasmer</code> WebAssembly runtime.</p>
<pre><code class="language-sh">$ wasmer ./.build/debug/hello-swiftwasm.wasm
Hello, world!
</code></pre>
<h1><a class="header" href="#porting-code-from-other-platforms-to-webassembly" id="porting-code-from-other-platforms-to-webassembly">Porting code from other platforms to WebAssembly</a></h1>
<p>In the form that's currently standardized and supported by browsers and other hosts, WebAssembly
is a 32-bit architecture. You have to take this into account when porting code from other
platforms, since <code>Int</code> type is a signed 32-bit integer, and <code>UInt</code> is an unsigned 32-bit integer
when building with SwiftWasm. You'll need to audit codepaths that cast 64-bit integers to <code>Int</code>
or <code>UInt</code>, and a good amount of cross-platform test coverage can help with that.</p>
<p>Additionally, there a differences in APIs exposed by the standard C library and Swift core
libraries which we discuss in the next few subsections.</p>
<h2><a class="header" href="#wasilibc-module" id="wasilibc-module"><code>WASILibc</code> module</a></h2>
<p>When porting existing projects from other platforms to SwiftWasm you might stumble upon code that
relies on importing a platform-specific <a href="https://en.wikipedia.org/wiki/C_standard_library">C
library</a> module directly. It looks like <code>import Glibc</code> on Linux, or <code>import Darwin</code> on Apple platforms. Fortunately, most of the standard C library
APIs are available when using SwiftWasm, you just need to use <code>import WASILibc</code> to get access to it.
Most probably you want to preserve compatibility with other platforms, thus your imports would look
like this:</p>
<pre><code class="language-swift">#if canImport(Darwin)
import Darwin
#elseif canImport(Glibc)
import Glibc
#elseif canImport(WASILibc)
import WASILibc
#endif
</code></pre>
<h3><a class="header" href="#limitations" id="limitations">Limitations</a></h3>
<p>WebAssembly and <a href="https://wasi.dev/">WASI</a> provide a constrained environment, which currently does
not directly support multi-threading, or filesystem access in the browser. Thus, you should not
expect these APIs to work when importing <code>WASILibc</code>. Please be aware of these limitations when
porting your code, which also has an impact on what <a href="getting-started/porting.html#swift-foundation-and-dispatch">can be supported in the Swift
Foundation</a> at the moment.</p>
<h2><a class="header" href="#swift-foundation-and-dispatch" id="swift-foundation-and-dispatch">Swift Foundation and Dispatch</a></h2>
<p><a href="https://swift.org/core-libraries/#foundation">The Foundation core library</a> is available in
SwiftWasm, but in a limited capacity. The main reason is that <a href="https://swift.org/core-libraries/#libdispatch">the Dispatch core
library</a> is unavailable due to <a href="https://github.com/swiftwasm/swift/issues/1887">the lack of 
standardized multi-threading support</a> in WebAssembly
and SwiftWasm itself. Many Foundation APIs rely on the presence of Dispatch under the hood,
specifically file system access and threading helpers. A few other types are unavailable in browsers
or aren't standardized in WASI hosts, such as support for sockets and low-level networking, or
support for time zone files, and they had to be disabled. These types are therefore absent in
SwiftWasm Foundation:</p>
<ul>
<li><code>FoundationNetworking</code> types, such as <code>URLSession</code> and related APIs</li>
<li><code>FileManager</code></li>
<li><code>Host</code></li>
<li><code>Notification</code></li>
<li><code>NotificationQueue</code></li>
<li><code>NSKeyedArchiver</code></li>
<li><code>NSKeyedArchiverHelpers</code></li>
<li><code>NSKeyedCoderOldStyleArray</code></li>
<li><code>NSKeyedUnarchiver</code></li>
<li><code>NSNotification</code></li>
<li><code>NSSpecialValue</code></li>
<li><code>Port</code></li>
<li><code>PortMessage</code></li>
<li><code>Process</code></li>
<li><code>ProcessInfo</code> (Partially available since 5.7)</li>
<li><code>PropertyListEncoder</code></li>
<li><code>RunLoop</code></li>
<li><code>Stream</code></li>
<li><code>Thread</code></li>
<li><code>Timer</code></li>
<li><code>UserDefaults</code></li>
</ul>
<p>Related functions and properties on other types are also absent or disabled. We would like to make
them available in the future as soon as possible, and <a href="getting-started/../contribution-guide/index.html">we invite you to 
contribute</a> and help us in achieving this goal!</p>
<h1><a class="header" href="#creating-a-browser-app" id="creating-a-browser-app">Creating a Browser App</a></h1>
<p>Currently, <a href="https://tokamak.dev">the Tokamak UI framework</a> is one of the easiest ways to build a
browser app with SwiftWasm. It tries to be compatible with <a href="https://developer.apple.com/xcode/swiftui/">the SwiftUI
API</a> as much as possible, which potentially allows
you to share most if not all code between SwiftWasm and other platforms.</p>
<h2><a class="header" href="#requirements-2" id="requirements-2">Requirements</a></h2>
<p>Tokamak relies on <a href="https://carton.dev">the <code>carton</code> development tool</a> for development and testing.
While you can build Tokamak apps without <code>carton</code>, that would require a lot of manual steps that are
already automated with <code>carton</code>.</p>
<h3><a class="header" href="#system-requirements" id="system-requirements">System Requirements</a></h3>
<ul>
<li>macOS 10.15 and Xcode 11.4 or later.</li>
<li><a href="https://swift.org/download/">Swift 5.2 or later</a> and Ubuntu 18.04 for Linux users.</li>
</ul>
<h3><a class="header" href="#installation-3" id="installation-3">Installation</a></h3>
<p>On macOS <code>carton</code> can be installed with <a href="https://brew.sh/">Homebrew</a>. Make sure you have Homebrew
installed and then run:</p>
<pre><code class="language-sh">brew install swiftwasm/tap/carton
</code></pre>
<p>You'll have to build <code>carton</code> from sources on Linux. Clone the repository and run
<code>swift build -c release</code>, the <code>carton</code> binary will be located in the <code>.build/release</code>
directory after that.
Assuming you already have Homebrew installed, you can create a new Tokamak
app by following these steps:</p>
<ol>
<li>Install <code>carton</code>:</li>
</ol>
<pre><code>brew install swiftwasm/tap/carton
</code></pre>
<p>If you had <code>carton</code> installed before this, make sure you have version 0.6.1 or greater:</p>
<pre><code>carton --version
</code></pre>
<ol start="2">
<li>Create a directory for your project and make it current:</li>
</ol>
<pre><code>mkdir TokamakApp &amp;&amp; cd TokamakApp
</code></pre>
<ol start="3">
<li>Initialize the project from a template with <code>carton</code>:</li>
</ol>
<pre><code>carton init --template tokamak
</code></pre>
<ol start="4">
<li>Build the project and start the development server, <code>carton dev</code> can be kept running
during development:</li>
</ol>
<pre><code>carton dev
</code></pre>
<ol start="5">
<li>Open <a href="http://127.0.0.1:8080/">http://127.0.0.1:8080/</a> in your browser to see the app
running. You can edit the app source code in your favorite editor and save it, <code>carton</code>
will immediately rebuild the app and reload all browser tabs that have the app open.</li>
</ol>
<p>You can also clone <a href="https://github.com/TokamakUI/Tokamak">the Tokamak repository</a> and run <code>carton dev</code> in its root directory. This will build the demo app that shows almost all of the currently
implemented APIs.</p>
<h1><a class="header" href="#javascript-interoperation" id="javascript-interoperation">JavaScript interoperation</a></h1>
<p><a href="https://github.com/swiftwasm/JavaScriptKit">JavaScriptKit</a> is a Swift framework to interact with JavaScript through WebAssembly.</p>
<p>You can use any JavaScript API from Swift with this library. Here's a quick example of JavaScriptKit
usage in a browser app:</p>
<pre><code class="language-swift">import JavaScriptKit

let document = JSObject.global.document

var divElement = document.createElement(&quot;div&quot;)
divElement.innerText = &quot;Hello, world&quot;
_ = document.body.appendChild(divElement)
</code></pre>
<p>You can also use JavaScriptKit in SwiftWasm apps integrated with Node.js, as there no assumptions
that any browser API is present in the library.</p>
<p>JavaScriptKit consists of a runtime library package <a href="https://www.npmjs.com/package/javascript-kit-swift">hosted on
npm</a>, and a SwiftPM package for the API on the
Swift side. To integrate the JavaScript runtime automatically into your app, we recommend following
the corresponding <a href="getting-started/./browser-app.html">guide for browser apps in our book</a>.</p>
<p>You can get more detailed JavaScriptKit documentation <a href="https://swiftwasm.github.io/JavaScriptKit/">here</a>.</p>
<h1><a class="header" href="#testing-your-app" id="testing-your-app">Testing your app</a></h1>
<p>You can write a test suite for your SwiftWasm app or library, or run an existing test suite
written for <code>XCTest</code> if you port existing code to SwiftWasm. Your project has to have a
<code>Package.swift</code> package manifest for this to work. We assume that you use SwiftPM to build your
project and that you have a working package manifest. Please follow <a href="getting-started/./swift-package.html">our SwiftPM guide</a> for new projects.</p>
<h2><a class="header" href="#a-simple-test-case" id="a-simple-test-case">A simple test case</a></h2>
<p>Let's assume you have a <code>SwiftWasmLibrary</code> target in your project that you'd like to test. Your
<code>Package.swift</code> should also have a test suite target with a dependency on the library target. It
would probably look like this:</p>
<pre><code class="language-swift">// swift-tools-version:5.3
// The swift-tools-version declares the minimum version of Swift required to build this package.

import PackageDescription

let package = Package(
  name: &quot;HelloSwiftWasm&quot;,
  products: [
    .executable(name: &quot;SwiftWasmApp&quot;, targets: [&quot;SwiftWasmApp&quot;]),
  ],
  targets: [
    // Targets are the basic building blocks of a package. A target can define a module or a test
    // suite. Targets can depend on other targets in this package, and on products in packages which
    // this package depends on.
    .target(
      name: &quot;SwiftWasmApp&quot;,
      dependencies: [&quot;SwiftWasmLibrary&quot;],
    ),
    .target(name: &quot;SwiftWasmLibrary&quot;),
    .testTarget(name: &quot;SwiftWasmTests&quot;, dependencies: [&quot;SwiftWasmLibrary&quot;]),
  ]
)
</code></pre>
<p>Now you should make sure there's <code>Tests/SwiftWasmTests</code> subdirectory in your project.
If you don't have any files in it yet, create <code>SwiftWasmTests.swift</code> in it:</p>
<pre><code class="language-swift">import SwiftWasmLibrary
import XCTest

final class SwiftWasmTests: XCTestCase {
  func testTrivial() {
    XCTAssertEqual(text, &quot;Hello, world&quot;)
  }
}
</code></pre>
<p>This code assumes that your <code>SwiftWasmLibrary</code> defines some <code>text</code> with <code>&quot;Hello, world&quot;</code> value
for this test to pass. Your test functions should all start with <code>test</code>, please see <a href="https://developer.apple.com/documentation/xctest/defining_test_cases_and_test_methods">XCTest 
documentation</a>
for more details.</p>
<h2><a class="header" href="#xctest-limitations-in-the-swiftwasm-toolchain" id="xctest-limitations-in-the-swiftwasm-toolchain">XCTest limitations in the SwiftWasm toolchain</a></h2>
<p>As was mentioned in <a href="getting-started//foundation.html">our section about Swift Foundation</a>, multi-threading and
file system APIs are currently not available in SwiftWasm. This means that <code>XCTestExpectation</code>
and test hooks related to <code>Bundle</code> (such as <code>testBundleWillStart(_:)</code> and <code>testBundleDidFinish(_:)</code>)
are not available in test suites compiled with SwiftWasm. If you have an existing test suite you're
porting to WebAssembly, you should use <code>#if os(WASI)</code> directives to exclude places where you use
these APIs from compilation.</p>
<h2><a class="header" href="#building-and-running-the-test-suite-with-carton" id="building-and-running-the-test-suite-with-carton">Building and running the test suite with <code>carton</code></a></h2>
<p>If you use <a href="https://carton.dev"><code>carton</code></a> to develop and build your app, as described in <a href="getting-started/./browser-app.html">our guide
for browser apps</a>, just run <code>carton test</code> in the
root directory of your package. This will automatically build the test suite and run it with 
<a href="https://wasmer.io/">Wasmer</a> for you.</p>
<h2><a class="header" href="#building-and-running-the-test-suite-with-swiftpm" id="building-and-running-the-test-suite-with-swiftpm">Building and running the test suite with <code>SwiftPM</code></a></h2>
<p>If you manage your SwiftWasm toolchain without <code>carton</code> (as shown in <a href="getting-started/./setup.html">the &quot;Setup&quot; section</a>),
you can build your test suite by running this command in your terminal:</p>
<pre><code class="language-sh">$ swift build --build-tests --triple wasm32-unknown-wasi
</code></pre>
<p>If you're used to running <code>swift test</code> to run test suites for other Swift platforms, we have to
warn you that this won't work. <code>swift test</code> doesn't know what WebAssembly environment you'd like to 
use to run your tests. Because of this building tests and running them are two separate steps when
using <code>SwiftPM</code>. After your tests are built, you can use a WASI-compatible host such as
<a href="https://wasmer.io/">Wasmer</a> to run the test bundle:</p>
<pre><code class="language-sh">$ wasmer .build/debug/HelloSwiftWasmPackageTests.xctest
</code></pre>
<p>As you can see, the produced test binary starts with the name of your package followed by
<code>PackageTests.xctest</code>. It is located in the <code>.build/debug</code> subdirectory, or in the <code>.build/release</code>
subdirectory when you build in release mode.</p>
<h1><a class="header" href="#examples" id="examples">Examples</a></h1>
<p>This section shows you example usage of our toolchain.</p>
<h1><a class="header" href="#importing-a-function-from-host-environments" id="importing-a-function-from-host-environments">Importing a function from host environments</a></h1>
<p>You can import a function from your host environment using the integration of Swift Package Manager
with C targets. Firstly, you should declare a signature for your function in a C header with an
appropriate <code>__import_name__</code> attribute:</p>
<pre><code class="language-c">__attribute__((__import_name__(&quot;add&quot;)))
extern int add(int lhs, int rhs);
</code></pre>
<p>Here <code>__import_name__</code> specifies the name under which this function will be exposed to Swift code.
Move this C header to a separate target, we'll call it <code>HostFunction</code> in this example. Your
<code>Package.swift</code> manifest for your WebAssembly app would look like this:</p>
<pre><code class="language-swift">// swift-tools-version:5.3
// The swift-tools-version declares the minimum version of Swift required to build this package.
import PackageDescription

let package = Package(
    name: &quot;SwiftWasmApp&quot;,
    targets: [
      .target(name: &quot;HostFunction&quot;, dependencies: []),
      .target(name: &quot;SwiftWasmApp&quot;, dependencies: [&quot;HostFunction&quot;]),
    ]
)
</code></pre>
<p>Place this header into the <code>include</code> subdirectory of your <code>HostFunction</code> target directory. You can
then import this host function module into Swift code just as any other module:</p>
<pre><code class="language-swift">import HostFunction

print(add(2, 2))
</code></pre>
<p>Then, you can inject a host function into the produced WebAssembly binary.</p>
<p>Note that we use <code>env</code> as default import module name. You can specify the module name as
<code>__import_module__</code> in your C header. The full list of attributes in the header could look
like <code>__attribute__((__import_module__(&quot;env&quot;),__import_name__(&quot;add&quot;)))</code>.</p>
<pre><code class="language-javascript">const WASI = require(&quot;@wasmer/wasi&quot;).WASI;
const WasmFs = require(&quot;@wasmer/wasmfs&quot;).WasmFs;

const promisify = require(&quot;util&quot;).promisify;
const fs = require(&quot;fs&quot;);
const readFile = promisify(fs.readFile);

const main = async () =&gt; {
  const wasmFs = new WasmFs();
  // Output stdout and stderr to console
  const originalWriteSync = wasmFs.fs.writeSync;
  wasmFs.fs.writeSync = (fd, buffer, offset, length, position) =&gt; {
    const text = new TextDecoder(&quot;utf-8&quot;).decode(buffer);
    switch (fd) {
      case 1:
        console.log(text);
        break;
      case 2:
        console.error(text);
        break;
    }
    return originalWriteSync(fd, buffer, offset, length, position);
  };

  // Instantiate a new WASI Instance
  let wasi = new WASI({
    args: [],
    env: {},
    bindings: {
      ...WASI.defaultBindings,
      fs: wasmFs.fs,
    },
  });

  const wasmBinary = await readFile(&quot;lib.wasm&quot;);

  // Instantiate the WebAssembly file
  let { instance } = await WebAssembly.instantiate(wasmBinary, {
    wasi_snapshot_preview1: wasi.wasiImport,
    env: {
      add: (lhs, rhs) =&gt; (lhs + rhs),
    }
  });

  wasi.start(instance);
};

main()
</code></pre>
<p>If you use Go bindings for Wasmer as your host environment, you should check <a href="https://github.com/hassan-shahbazi/swiftwasm-go">an example 
repository</a> from one of our contributors that shows
an integration with an imported host function.</p>
<p>A more streamlined way to import host functions will be implemented in the future version of the
SwiftWasm toolchain.</p>
<h1><a class="header" href="#exporting-function-for-host-environment" id="exporting-function-for-host-environment">Exporting function for host environment</a></h1>
<p>You can expose a Swift function for host environment using special attribute and linker option.</p>
<pre><code class="language-swift">@_cdecl(&quot;add&quot;)
func add(_ lhs: Int, _ rhs: Int) -&gt; Int {
    return lhs + rhs
}
</code></pre>
<p>You need to compile the Swift code with linker option <code>--export</code>.</p>
<pre><code class="language-bash">$ swiftc \
    -target wasm32-unknown-wasi \
    lib.swift -o lib.wasm \
    -Xlinker --export=add
</code></pre>
<p>Then, you can use the exported function from host environment.</p>
<pre><code class="language-javascript">const WASI = require(&quot;@wasmer/wasi&quot;).WASI;
const WasmFs = require(&quot;@wasmer/wasmfs&quot;).WasmFs;

const promisify = require(&quot;util&quot;).promisify;
const fs = require(&quot;fs&quot;);
const readFile = promisify(fs.readFile);

const main = async () =&gt; {
  // Instantiate a new WASI Instance
  const wasmFs = new WasmFs();
  let wasi = new WASI({
    args: [],
    env: {},
    bindings: {
      ...WASI.defaultBindings,
      fs: wasmFs.fs,
    },
  });

  const wasmBinary = await readFile(&quot;lib.wasm&quot;);

  // Instantiate the WebAssembly file
  let { instance } = await WebAssembly.instantiate(wasmBinary, {
    wasi_snapshot_preview1: wasi.wasiImport,
  });
  // Get the exported function
  const addFn = instance.exports.add;
  console.log(&quot;2 + 3 = &quot; + addFn(2, 3))

};

main()
</code></pre>
<p>If you use SwiftPM package, you can omit linker flag using clang's <code>__atribute__</code>. Please see <a href="https://github.com/swiftwasm/JavaScriptKit/pull/91/files">swiftwasm/JavaScriptKit#91</a> for more detail info</p>
<h2><a class="header" href="#example-projects" id="example-projects">Example Projects</a></h2>
<p>You can learn more practical usage of our toolchain in <a href="https://github.com/swiftwasm/awesome-swiftwasm">swiftwasm/awesome-swiftwasm</a></p>
<h1><a class="header" href="#contribution-guide" id="contribution-guide">Contribution Guide</a></h1>
<h2><a class="header" href="#forum-posts" id="forum-posts">Forum posts</a></h2>
<ul>
<li><a href="https://forums.swift.org/t/wasm-support/16087/14">Design of this project</a></li>
<li><a href="https://forums.swift.org/t/webassembly-swiftpm/34343">Swift Package Manager Support</a></li>
</ul>
<h2><a class="header" href="#repositories" id="repositories">Repositories</a></h2>
<h3><a class="header" href="#a-hrefhttpsgithubcomswiftwasmswiftswiftwasmswifta" id="a-hrefhttpsgithubcomswiftwasmswiftswiftwasmswifta"><a href="https://github.com/swiftwasm/swift">swiftwasm/swift</a></a></h3>
<p>The main repository of this project. Forked from <a href="https://github.com/swiftwasm/swift">apple/swift</a>. We are tracking upstream changes using <a href="https://github.com/wei/pull">pull</a></p>
<h4><a class="header" href="#branching-scheme" id="branching-scheme">Branching scheme</a></h4>
<ul>
<li><code>swiftwasm</code> is the main development branch.</li>
<li><code>main</code> is a mirror of the <code>main</code> branch of the upstream <code>apple/swift</code> repository. This branch is necessary to avoid <a href="https://github.com/swiftwasm/swift/pull/36">some issues</a>.</li>
<li><code>swiftwasm-release/5.3</code> is the branch where 5.3 release of SwiftWasm is prepared.</li>
<li><code>release/5.3</code> is a mirror of the upstream <code>release/5.3</code> branch.</li>
</ul>
<h3><a class="header" href="#a-hrefhttpsgithubcomswiftwasmllvm-projectswiftwasmllvm-projecta" id="a-hrefhttpsgithubcomswiftwasmllvm-projectswiftwasmllvm-projecta"><a href="https://github.com/swiftwasm/llvm-project">swiftwasm/llvm-project</a></a></h3>
<p>This repository is a fork of <a href="https://github.com/apple/llvm-project">apple/llvm-project</a>.</p>
<p><code>swiftwasm</code> branch is based on <code>swift/main</code> branch of <code>apple/llvm-project</code>.</p>
<p>Please see the <a href="https://github.com/apple/llvm-project/blob/apple/main/apple-docs/AppleBranchingScheme.md">AppleBranchingScheme.md</a>
document in the upstream repository for more details.</p>
<h3><a class="header" href="#a-hrefhttpsgithubcomswiftwasmicu4c-wasiswiftwasmicu4c-wasia" id="a-hrefhttpsgithubcomswiftwasmicu4c-wasiswiftwasmicu4c-wasia"><a href="https://github.com/swiftwasm/icu4c-wasi">swiftwasm/icu4c-wasi</a></a></h3>
<p>Build script and patches for building ICU project for WebAssembly. <a href="https://github.com/unicode-org/icu/pull/990">The required changes to build 
it</a> were merged to the upstream repository.</p>
<h3><a class="header" href="#a-hrefhttpsgithubcomswiftwasmwasi-sdkswiftwasmwasi-sdka-and-a-hrefhttpsgithubcomswiftwasmwasi-libcswiftwasmwasi-libca" id="a-hrefhttpsgithubcomswiftwasmwasi-sdkswiftwasmwasi-sdka-and-a-hrefhttpsgithubcomswiftwasmwasi-libcswiftwasmwasi-libca"><a href="https://github.com/swiftwasm/wasi-sdk">swiftwasm/wasi-sdk</a> and <a href="https://github.com/swiftwasm/wasi-libc">swiftwasm/wasi-libc</a></a></h3>
<p>Forked from <a href="https://github.com/WebAssembly/wasi-sdk">WebAssembly/wasi-sdk</a> and <a href="https://github.com/WebAssembly/wasi-libc">WebAssembly/wasi-libc</a>.</p>
<p>We fork them to build <code>wasi-sysroot</code> with pthread header. There aren't so many diff from upstream.</p>
<h1><a class="header" href="#how-to-build-toolchain" id="how-to-build-toolchain">How to build toolchain</a></h1>
<h2><a class="header" href="#1-checkout-the-project-source-code" id="1-checkout-the-project-source-code">1. Checkout the project source code.</a></h2>
<pre><code class="language-sh">$ mkdir swiftwasm-source
$ cd swiftwasm-source
$ git clone https://github.com/swiftwasm/swift.git
$ ./swift/utils/update-checkout --scheme wasm --clone
</code></pre>
<h2><a class="header" href="#2-install-required-dependencies" id="2-install-required-dependencies">2. Install required dependencies</a></h2>
<p>Before building Swift, please install required dependencies.</p>
<pre><code class="language-sh"># On macOS
$ brew install cmake ninja llvm sccache wasmer
$ ./utils/webassembly/macos/install-dependencies.sh
# On Linux
$ ./utils/webassembly/linux/install-dependencies.sh
</code></pre>
<h2><a class="header" href="#3-build-using-custom-preset-options" id="3-build-using-custom-preset-options">3. Build using custom preset options</a></h2>
<p>We support both Linux and macOS to build Swift. You need to select the preset name, <code>sccache</code> path and LLVM tools directory.</p>
<pre><code class="language-sh"># On macOS
$ ./utils/build-script \
        --preset=webassembly-macos-target \
        --preset-file ./utils/webassembly/build-presets.ini  \
        SOURCE_PATH=$(dirname $(pwd)) \
        LLVM_BIN_DIR=/usr/local/opt/llvm/bin \
        C_CXX_LAUNCHER=$(which sccache)
# On Linux
$ ./utils/build-script \
        --preset=webassembly-linux-target \
        --preset-file ./utils/webassembly/build-presets.ini  \
        SOURCE_PATH=$(dirname $(pwd)) \
        LLVM_BIN_DIR=/usr/local/opt/llvm/bin \
        C_CXX_LAUNCHER=$(which sccache)
</code></pre>
<p>Or if you want to build whole toolchain, please use <code>./utils/webassembly/build-toolchain.sh</code>. This script builds compiler, Swift Standard Library for host environment (e.g. macOS or Linux) and target environment (<code>wasm32-unknown-wasi</code>), Foundation and other packages. So it takes longer time than the above script.</p>
<pre><code class="language-bash">$ ./utils/webassembly/build-toolchain.sh
</code></pre>
<p>If you want to get more information about build system, please feel free to ask @kateinoigakukun on Twitter or GitHub.</p>
<h2><a class="header" href="#continuous-integration" id="continuous-integration">Continuous Integration</a></h2>
<p>We use GitHub Actions to build and run tests continuously.
(But jobs without cache takes 2~3 hours to be completed)</p>
<p>Currently (2020/10/4), we only run stdlib tests on Linux CI because the job execution time and storage reached GitHub Actions limits.</p>
<p>References:</p>
<ul>
<li><a href="https://github.com/swiftwasm/swift/pull/160#issuecomment-586537014">swiftwasm/swift#160</a></li>
<li><a href="https://github.com/swiftwasm/swift/pull/232">swiftwasm/swift#232</a></li>
</ul>
<h3><a class="header" href="#nightly-distribution" id="nightly-distribution">Nightly distribution</a></h3>
<p>We distribute latest <code>swiftwasm</code> branch and <code>swiftwasm-release/5.3</code> branch toolchains at UTC 00:00 everyday. You can check the latest toolchain at <a href="https://github.com/swiftwasm/swift/releases">GitHub Release Page</a></p>
<h2><a class="header" href="#cache" id="cache">Cache</a></h2>
<p>Compilation time of LLVM and the Swift toolchain is very long, so we recommend to cache the artifacts using <code>sccache</code>. <a href="https://github.com/apple/swift/blob/main/docs/HowToGuides/GettingStarted.md#the-roles-of-different-tools">The &quot;Getting started&quot; guide</a> from the upstream toolchain provides more details about the use of <code>sccache</code>.</p>
<h3><a class="header" href="#references" id="references">References</a></h3>
<ul>
<li><a href="https://github.com/mozilla/sccache">mozilla/sccache</a></li>
<li><a href="https://github.com/apple/swift/blob/master/docs/DevelopmentTips.md#use-sccache-to-cache-build-artifacts">Use sccache to cache build artifacts</a></li>
</ul>
<h2><a class="header" href="#debugging" id="debugging">Debugging</a></h2>
<p>When you want to debug a WebAssembly binary, <a href="https://github.com/kateinoigakukun/wasminspect">wasminspect</a> 
can help in the investigation if the debugged binary does not rely on integration with JavaScript.
We recommend splitting your packages into separate executable targets, most of which shouldn't 
assume the availability of JavaScript to make debugging easier.</p>
<p><img src="https://raw.githubusercontent.com/kateinoigakukun/wasminspect/master/assets/demo.gif" alt="demo" /></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
