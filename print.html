<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Swift and WebAssembly</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="getting-started/index.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="getting-started/setup.html"><strong aria-hidden="true">2.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="getting-started/porting.html"><strong aria-hidden="true">2.2.</strong> Porting code</a></li><li class="chapter-item expanded "><a href="getting-started/browser-app.html"><strong aria-hidden="true">2.3.</strong> Creating a browser app</a></li><li class="chapter-item expanded "><a href="getting-started/javascript-interop.html"><strong aria-hidden="true">2.4.</strong> JavaScript interoperation</a></li><li class="chapter-item expanded "><a href="getting-started/concurrency.html"><strong aria-hidden="true">2.5.</strong> Concurrency</a></li><li class="chapter-item expanded "><a href="getting-started/multithreading.html"><strong aria-hidden="true">2.6.</strong> Multithreading</a></li><li class="chapter-item expanded "><a href="getting-started/testing.html"><strong aria-hidden="true">2.7.</strong> Testing your app</a></li><li class="chapter-item expanded "><a href="getting-started/vscode.html"><strong aria-hidden="true">2.8.</strong> Visual Studio Code</a></li><li class="chapter-item expanded "><a href="getting-started/debugging.html"><strong aria-hidden="true">2.9.</strong> Debugging</a></li><li class="chapter-item expanded "><a href="getting-started/troubleshooting.html"><strong aria-hidden="true">2.10.</strong> Troubleshooting</a></li></ol></li><li class="chapter-item expanded "><a href="examples/index.html"><strong aria-hidden="true">3.</strong> Examples</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="examples/importing-function.html"><strong aria-hidden="true">3.1.</strong> Importing function</a></li><li class="chapter-item expanded "><a href="examples/exporting-function.html"><strong aria-hidden="true">3.2.</strong> Exporting function</a></li><li class="chapter-item expanded "><a href="examples/example-projects.html"><strong aria-hidden="true">3.3.</strong> Example projects</a></li></ol></li><li class="chapter-item expanded "><a href="contribution-guide/index.html"><strong aria-hidden="true">4.</strong> Contribution Guide</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="contribution-guide/how-to-build-toolchain.html"><strong aria-hidden="true">4.1.</strong> How to build the toolchain</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Swift and WebAssembly</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>Welcome to the SwiftWasm Documentation!</p>
<p><a href="https://github.com/swiftwasm">SwiftWasm is an open source project to support the WebAssembly target for Swift.</a></p>
<p>The goal of this project is to fully support the WebAssembly target for <a href="https://swift.org">Swift</a> and to be merged into <a href="https://github.com/apple/swift">the upstream repository</a>.</p>
<p>WebAssembly is described on its <a href="https://webassembly.org/">home page</a> as:</p>
<blockquote>
<p>WebAssembly (abbreviated as Wasm) is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications.</p>
</blockquote>
<p>We use LLVM as a compiler backend to produce WebAssembly binaries. Our resulting binaries also depend on <a href="https://wasi.dev">WASI</a>, which is a modular system interface for WebAssembly. WASI is mainly required to compile Swift Standard Library.</p>
<h3><a class="header" href="#important-note" id="important-note">Important note</a></h3>
<p>In 2024, Apple introduced <a href="https://github.com/swiftlang/swift/blob/main/docs/EmbeddedSwift/UserManual.md">Swift Embedded</a>. 
While both projects benefit from each other, it is important to understand that they are different targets at the build phase, consequentially with different sets of abilities.
Embedded Swift <a href="https://github.com/swiftlang/swift/blob/main/docs/EmbeddedSwift/EmbeddedSwiftStatus.md#embedded-swift-language-features">very limited</a> but can produce small binaries. <a href="https://github.com/apple/swift-for-wasm-examples">Example</a>.</p>
<h2><a class="header" href="#project-status" id="project-status">Project Status</a></h2>
<p><a href="https://forums.swift.org/t/stdlib-and-runtime-tests-for-wasm-wasi-now-available-on-swift-ci/70385">All compiler and standard library changes have been upstreamed to the official Swift repository, and the upstream CI is now testing WebAssembly targets.</a></p>
<p>The remaining works are:</p>
<ul>
<li>Integrating the build system with the official Swift CI.</li>
</ul>
<h1><a class="header" href="#getting-started" id="getting-started">Getting Started</a></h1>
<p>This is a getting started guide section to use SwiftWasm.</p>
<p>You can learn about:</p>
<ul>
<li>How to set up a Swift toolchain for compiling to WebAssembly</li>
<li>How to compile a simple Swift code and Swift Package into WebAssembly</li>
<li>How to interoperate with JavaScript</li>
</ul>
<h1><a class="header" href="#installation---latest-release-swift-603" id="installation---latest-release-swift-603">Installation - Latest Release (Swift 6.0.3)</a></h1>
<p>SwiftWasm provides <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0387-cross-compilation-destinations.md">Swift SDK</a>s for WebAssembly.</p>
<p>Before installing the Swift SDK, you need to ensure the following:</p>
<ul>
<li>You need to <a href="https://www.swift.org/install/">install an Open Source toolchain from swift.org</a>. (Not the Xcode toolchain)</li>
<li>You cannot use toolchains bundled with Xcode to use the Swift SDK.</li>
<li>If you are using macOS, please follow the <a href="https://www.swift.org/install/macos/package_installer/">official guide</a> to install the toolchain.</li>
</ul>
<p>Please ensure you have installed the Swift 6.0.3 Open Source toolchain.</p>
<pre><code class="language-sh">swift --version
</code></pre>
<table><thead><tr><th>Toolchain</th><th>Output</th></tr></thead><tbody>
<tr><td>‚ùå Xcode</td><td><code>Apple Swift version 6.0.3 (swiftlang-6.0.3.1.10 clang-1600.0.30.1)</code></td></tr>
<tr><td>‚úÖ Open Source (macOS)</td><td><code>Apple Swift version 6.0.3 (swift-6.0.3-RELEASE)</code></td></tr>
<tr><td>‚úÖ Open Source (Others)</td><td><code>Swift version 6.0.3 (swift-6.0.3-RELEASE)</code></td></tr>
</tbody></table>
<p>Once you have installed the Open Source toolchain, you can install the Swift SDK for WebAssembly:</p>
<pre><code class="language-bash">swift sdk install &quot;https://github.com/swiftwasm/swift/releases/download/swift-wasm-6.0.3-RELEASE/swift-wasm-6.0.3-RELEASE-wasm32-unknown-wasi.artifactbundle.zip&quot; --checksum &quot;31d3585b06dd92de390bacc18527801480163188cd7473f492956b5e213a8618&quot;
</code></pre>
<p>After installing the Swift SDK, you can see <code>6.0.3-RELEASE-wasm32-unknown-wasi</code> in the Swift SDK list:</p>
<pre><code class="language-bash">swift sdk list
</code></pre>
<p>You can also find other SDKs from <a href="https://github.com/swiftwasm/swift/releases">the GitHub Releases page</a>.</p>
<h2><a class="header" href="#hello-world" id="hello-world">Hello, World</a></h2>
<p>First, create a new directory for your project and navigate into it:</p>
<pre><code class="language-bash">$ mkdir hello &amp;&amp; cd hello
</code></pre>
<p>Create a new Swift package:</p>
<pre><code class="language-bash">$ swift package init --type executable
</code></pre>
<p>You can use the installed SDKs to cross-compile Swift packages for WebAssembly:</p>
<pre><code class="language-bash">$ swift build --swift-sdk wasm32-unknown-wasi
...
$ file .build/wasm32-unknown-wasi/debug/hello.wasm
.build/wasm32-unknown-wasi/debug/hello.wasm: WebAssembly (wasm) binary module version 0x1 (MVP)
</code></pre>
<p>You can run the built WebAssembly module using <a href="https://wasmtime.dev/"><code>wasmtime</code></a>:</p>
<pre><code class="language-bash">$ wasmtime .build/wasm32-unknown-wasi/debug/hello.wasm
Hello, world!
</code></pre>
<h2><a class="header" href="#faq" id="faq">FAQ</a></h2>
<h3><a class="header" href="#how-to-check-if-i-am-using-open-source-toolchain-or-xcode-toolchain" id="how-to-check-if-i-am-using-open-source-toolchain-or-xcode-toolchain">How to check if I am using Open Source toolchain or Xcode toolchain?</a></h3>
<pre><code class="language-bash">$ swift --version | head -n1
</code></pre>
<table><thead><tr><th>Toolchain</th><th>Output</th></tr></thead><tbody>
<tr><td>Xcode</td><td><code>Apple Swift version 6.0.3 (swiftlang-6.0.3.1.10 clang-1600.0.30.1)</code></td></tr>
<tr><td>Open Source (macOS)</td><td><code>Apple Swift version 6.0.3 (swift-6.0.3-RELEASE)</code></td></tr>
<tr><td>Open Source (Others)</td><td><code>Swift version 6.0.3 (swift-6.0.3-RELEASE)</code></td></tr>
</tbody></table>
<h3><a class="header" href="#unknown0-error-module-compiled-with-swift-603-cannot-be-imported-by-the-swift-xyz" id="unknown0-error-module-compiled-with-swift-603-cannot-be-imported-by-the-swift-xyz"><code>&lt;unknown&gt;:0: error: module compiled with Swift 6.0.3 cannot be imported by the Swift x.y.z</code></a></h3>
<p>This error occurs when the Swift toolchain version you are using is different from the version of the Swift SDK you have installed.</p>
<p>To resolve this issue, you can either:</p>
<ol>
<li>Switch the Swift toolchain to the same version as the Swift SDK you have installed. Check the <a href="https://www.swift.org/install/macos/package_installer/">official guide</a> for how to switch the toolchain.</li>
<li>Install the Swift SDK for the same version as the Swift toolchain you are using.
Use the following shell snippet to query compatible Swift SDK for your current toolchain version:</li>
</ol>
<pre><code class="language-console">(
  V=&quot;$(swiftc --version | head -n1)&quot;; \
  TAG=&quot;$(curl -sL &quot;https://raw.githubusercontent.com/swiftwasm/swift-sdk-index/refs/heads/main/v1/tag-by-version.json&quot; | jq -r --arg v &quot;$V&quot; '.[$v] | .[-1]')&quot;; \
  curl -sL &quot;https://raw.githubusercontent.com/swiftwasm/swift-sdk-index/refs/heads/main/v1/builds/$TAG.json&quot; | \
  jq -r '.[&quot;swift-sdks&quot;][&quot;wasm32-unknown-wasi&quot;] | &quot;swift sdk install \&quot;\(.url)\&quot; --checksum \&quot;\(.checksum)\&quot;&quot;'
)
</code></pre>
<h3><a class="header" href="#what-is-the-difference-between-the-swift-toolchain-and-the-swift-sdk" id="what-is-the-difference-between-the-swift-toolchain-and-the-swift-sdk">What is the difference between the Swift Toolchain and the Swift SDK?</a></h3>
<p>The Swift toolchain is a complete package that includes the Swift compiler, standard library, and other tools.</p>
<p>The Swift SDK includes a subset of the Swift toolchain that includes only the necessary components for cross-compilation and some supplementary resources.</p>
<h3><a class="header" href="#what-is-included-in-the-swift-sdk-for-webassembly" id="what-is-included-in-the-swift-sdk-for-webassembly">What is included in the Swift SDK for WebAssembly?</a></h3>
<p>The Swift SDK for WebAssembly includes only the pre-built Swift standard libraries for WebAssembly. It does not include the Swift compiler or other tools that are part of the Swift toolchain.</p>
<h1><a class="header" href="#porting-code-to-webassembly-with-wasi" id="porting-code-to-webassembly-with-wasi">Porting code to WebAssembly with WASI</a></h1>
<p>In the form that's currently standardized and supported by browsers and other hosts, WebAssembly
is a 32-bit architecture. You have to take this into account when porting code from other
platforms, since <code>Int</code> type is a signed 32-bit integer, and <code>UInt</code> is an unsigned 32-bit integer
when building with SwiftWasm. You'll need to audit codepaths that cast 64-bit integers to <code>Int</code>
or <code>UInt</code>, and a good amount of cross-platform test coverage can help with that.</p>
<p>Additionally, there a differences in APIs exposed by the standard C library and Swift core
libraries which we discuss in the next few subsections.</p>
<h2><a class="header" href="#wasilibc-module" id="wasilibc-module"><code>WASILibc</code> module</a></h2>
<p>When porting existing projects from other platforms to SwiftWasm you might stumble upon code that
relies on importing a platform-specific <a href="https://en.wikipedia.org/wiki/C_standard_library">C
library</a> module directly. It looks like <code>import Glibc</code> on Linux, or <code>import Darwin</code> on Apple platforms. Fortunately, most of the standard C library
APIs are available when using SwiftWasm, you just need to use <code>import WASILibc</code> to get access to it.
Most probably you want to preserve compatibility with other platforms, thus your imports would look
like this:</p>
<pre><code class="language-swift">#if canImport(Darwin)
import Darwin
#elseif canImport(Glibc)
import Glibc
#elseif canImport(WASILibc)
import WASILibc
#endif
</code></pre>
<h3><a class="header" href="#limitations" id="limitations">Limitations</a></h3>
<p>WebAssembly and <a href="https://wasi.dev/">WASI</a> provide a constrained environment, which currently does
not directly support multi-threading. Thus, you should not
expect these APIs to work when importing <code>WASILibc</code>. Please be aware of these limitations when
porting your code, which also has an impact on what <a href="getting-started/porting.html#swift-foundation-and-dispatch">can be supported in the Swift
Foundation</a> at the moment.</p>
<h2><a class="header" href="#swift-foundation-and-dispatch" id="swift-foundation-and-dispatch">Swift Foundation and Dispatch</a></h2>
<p><a href="https://swift.org/core-libraries/#foundation">The Foundation core library</a> is available in
SwiftWasm, but in a limited capacity. The main reason is that <a href="https://swift.org/core-libraries/#libdispatch">the Dispatch core
library</a> is unavailable due to <a href="https://github.com/swiftwasm/swift/issues/1887">the lack of 
standardized multi-threading support</a> in WebAssembly
and SwiftWasm itself. Many Foundation APIs rely on the presence of Dispatch under the hood,
specifically threading helpers. A few other types are unavailable in browsers
or aren't standardized in WASI hosts, such as support for sockets and low-level networking,
and they had to be disabled. These types are therefore absent in SwiftWasm Foundation:</p>
<table><thead><tr><th>Type or module</th><th>Status</th></tr></thead><tbody>
<tr><td><code>FoundationNetworking</code></td><td>‚ùå Unavailable</td></tr>
<tr><td><code>FileManager</code></td><td>‚úÖ Available after 6.0</td></tr>
<tr><td><code>Host</code></td><td>‚úÖ Partially available after 6.0</td></tr>
<tr><td><code>Notification</code></td><td>‚úÖ Available after 6.0</td></tr>
<tr><td><code>NotificationQueue</code></td><td>‚ùå Unavailable</td></tr>
<tr><td><code>NSKeyedArchiver</code></td><td>‚úÖ Available after 6.0</td></tr>
<tr><td><code>NSKeyedArchiverHelpers</code></td><td>‚úÖ Available after 6.0</td></tr>
<tr><td><code>NSKeyedCoderOldStyleArray</code></td><td>‚úÖ Available after 6.0</td></tr>
<tr><td><code>NSKeyedUnarchiver</code></td><td>‚úÖ Available after 6.0</td></tr>
<tr><td><code>NSNotification</code></td><td>‚úÖ Available after 6.0</td></tr>
<tr><td><code>NSSpecialValue</code></td><td>‚úÖ Available after 6.0</td></tr>
<tr><td><code>Port</code></td><td>‚úÖ Available after 6.0</td></tr>
<tr><td><code>PortMessage</code></td><td>‚úÖ Available after 6.0</td></tr>
<tr><td><code>Process</code></td><td>‚ùå Unavailable</td></tr>
<tr><td><code>ProcessInfo</code></td><td>‚úÖ Partially available after 5.7</td></tr>
<tr><td><code>PropertyListEncoder</code></td><td>‚úÖ Available after 6.0</td></tr>
<tr><td><code>RunLoop</code></td><td>‚ùå Unavailable</td></tr>
<tr><td><code>Stream</code></td><td>‚úÖ Partially available after 6.0</td></tr>
<tr><td><code>SocketPort</code></td><td>‚ùå Unavailable</td></tr>
<tr><td><code>Thread</code></td><td>‚ùå Unavailable</td></tr>
<tr><td><code>Timer</code></td><td>‚ùå Unavailable</td></tr>
<tr><td><code>UserDefaults</code></td><td>‚úÖ Available after 6.0</td></tr>
</tbody></table>
<p>Related functions and properties on other types are also absent or disabled. We would like to make
them available in the future as soon as possible, and <a href="getting-started/../contribution-guide/index.html">we invite you to 
contribute</a> and help us in achieving this goal!</p>
<h2><a class="header" href="#xctest" id="xctest">XCTest</a></h2>
<p><a href="https://github.com/swiftlang/swift-corelibs-xctest">The swift-corelibs-xctest project</a> is available
in WebAssembly platforms, and you can use it to write tests for your SwiftWasm projects.</p>
<p>The following XCTest features are unavailable in SwiftWasm:</p>
<table><thead><tr><th>API</th><th>Status</th></tr></thead><tbody>
<tr><td><code>XCTestExpectation</code></td><td>‚ùå Unavailable</td></tr>
<tr><td><code>XCTNSPredicateExpectation</code></td><td>‚ùå Unavailable</td></tr>
<tr><td><code>XCTNSNotificationExpectation</code></td><td>‚ùå Unavailable</td></tr>
<tr><td><code>XCTWaiter</code></td><td>‚ùå Unavailable</td></tr>
<tr><td><code>XCTest.perform</code></td><td>‚ùå Unavailable</td></tr>
<tr><td><code>XCTest.run</code></td><td>‚ùå Unavailable</td></tr>
</tbody></table>
<h1><a class="header" href="#creating-a-browser-app" id="creating-a-browser-app">Creating a Browser App</a></h1>
<p>Currently, <a href="https://tokamak.dev">the Tokamak UI framework</a> is one of the easiest ways to build a
browser app with SwiftWasm. It tries to be compatible with <a href="https://developer.apple.com/xcode/swiftui/">the SwiftUI
API</a> as much as possible, which potentially allows
you to share most if not all code between SwiftWasm and other platforms.</p>
<h2><a class="header" href="#requirements" id="requirements">Requirements</a></h2>
<p>Tokamak relies on <a href="https://carton.dev">the <code>carton</code> development tool</a> for development and testing.
While you can build Tokamak apps without <code>carton</code>, that would require a lot of manual steps that are
already automated with <code>carton</code>.</p>
<h3><a class="header" href="#system-requirements" id="system-requirements">System Requirements</a></h3>
<ul>
<li><a href="https://swift.org/download/">Swift 5.9.2</a></li>
</ul>
<blockquote>
<p>Important:
Tokamak UI currently is not compatible with swift 6.0+. </p>
</blockquote>
<h3><a class="header" href="#installation" id="installation">Installation</a></h3>
<ol>
<li>Create a directory for your project and make it current:</li>
</ol>
<pre><code>mkdir MyApp &amp;&amp; cd MyApp
</code></pre>
<ol start="2">
<li>Initialize the project:</li>
</ol>
<pre><code>swift package init --type executable
</code></pre>
<ol start="3">
<li>Add Tokamak and carton as dependencies to your <code>Package.swift</code>:</li>
</ol>
<pre><code class="language-swift">// swift-tools-version:5.8
import PackageDescription
let package = Package(
    name: &quot;MyApp&quot;,
    platforms: [.macOS(.v11), .iOS(.v13)],
    dependencies: [
        .package(url: &quot;https://github.com/TokamakUI/Tokamak&quot;, from: &quot;0.11.0&quot;),
        .package(url: &quot;https://github.com/swiftwasm/carton&quot;, from: &quot;1.0.0&quot;),
    ],
    targets: [
        .executableTarget(
            name: &quot;MyApp&quot;,
            dependencies: [
                .product(name: &quot;TokamakShim&quot;, package: &quot;Tokamak&quot;)
            ]),
    ]
)
</code></pre>
<ol start="4">
<li>Add your first view to <code>Sources/MyApp/main.swift</code>:</li>
</ol>
<pre><code class="language-swift">import TokamakDOM

@main
struct TokamakApp: App {
    var body: some Scene {
        WindowGroup(&quot;Tokamak App&quot;) {
            ContentView()
        }
    }
}

struct ContentView: View {
    var body: some View {
        Text(&quot;Hello, world!&quot;)
    }
}
</code></pre>
<ol start="5">
<li>Build the project and start the development server, <code>swift run carton dev</code> can be kept running
during development:</li>
</ol>
<pre><code>swift run carton dev
</code></pre>
<ol start="6">
<li>Open <a href="http://127.0.0.1:8080/">http://127.0.0.1:8080/</a> in your browser to see the app
running. You can edit the app source code in your favorite editor and save it, <code>carton</code>
will immediately rebuild the app and reload all browser tabs that have the app open.</li>
</ol>
<p>You can also clone <a href="https://github.com/TokamakUI/Tokamak">the Tokamak repository</a> and run <code>carton dev --product TokamakDemo</code> in its root directory. This will build the demo app that shows almost all of the currently
implemented APIs.</p>
<h1><a class="header" href="#javascript-interoperation" id="javascript-interoperation">JavaScript interoperation</a></h1>
<p><a href="https://github.com/swiftwasm/JavaScriptKit">JavaScriptKit</a> is a Swift framework to interact with JavaScript through WebAssembly.</p>
<p>You can use any JavaScript API from Swift with this library. Here's a quick example of JavaScriptKit
usage in a browser app:</p>
<pre><code class="language-swift">import JavaScriptKit

let document = JSObject.global.document

var divElement = document.createElement(&quot;div&quot;)
divElement.innerText = &quot;Hello, world&quot;
_ = document.body.appendChild(divElement)
</code></pre>
<p>You can also use JavaScriptKit in SwiftWasm apps integrated with Node.js, as there no assumptions
that any browser API is present in the library.</p>
<p>JavaScriptKit consists of a runtime library package <a href="https://www.npmjs.com/package/javascript-kit-swift">hosted on
npm</a>, and a SwiftPM package for the API on the
Swift side. To integrate the JavaScript runtime automatically into your app, we recommend following
the corresponding <a href="getting-started/./browser-app.html">guide for browser apps in our book</a>.</p>
<p>You can get more detailed JavaScriptKit documentation <a href="https://swiftwasm.github.io/JavaScriptKit/">here</a>.</p>
<h1><a class="header" href="#running-async-functions-in-webassembly" id="running-async-functions-in-webassembly">Running <code>async</code> functions in WebAssembly</a></h1>
<p>On macOS, iOS, and Linux, <code>libdispatch</code>-based executor is used by default, but <code>libdispatch</code> is not supported in single-threaded WebAssembly environment.
However, there are still two global task executors available in SwiftWasm.</p>
<p>If you need multi-threading support on Web, please see <a href="getting-started/./multithreading.html">Multithreading guide</a> for more details.</p>
<h2><a class="header" href="#cooperative-task-executor" id="cooperative-task-executor">Cooperative Task Executor</a></h2>
<p><code>Cooperative Task Executor</code> is the default task executor in SwiftWasm. It is a simple single-threaded cooperative task executor implemented in <a href="https://github.com/apple/swift/blob/0c67ce64874d83b2d4f8d73b899ee58f2a75527f/stdlib/public/Concurrency/CooperativeGlobalExecutor.inc">Swift Concurrency library</a>.
If you are not familiar with &quot;Cooperative&quot; in concurrent programming term, see <a href="https://en.wikipedia.org/wiki/Cooperative_multitasking">its definition for more details</a>.</p>
<p>This executor has an <em>event loop</em> that dispatches tasks until no more tasks are enqueued, and exits immediately after all tasks are dispatched.
Note that this executor won't yield control to the host environment during execution, so any host's async operation cannot call back to the Wasm execution.</p>
<p>This executor is suitable for WASI command line tools, or host-independent standalone applications.</p>
<pre><code class="language-swift">// USAGE
// $ swiftc -target wasm32-unknown-wasi -parse-as-library main.swift -o main.wasm
// $ wasmtime main.wasm
@main
struct Main {
    static func main() async throws {
        print(&quot;Sleeping for 1 second... üò¥&quot;)
        try await Task.sleep(nanoseconds: 1_000_000_000)
        print(&quot;Wake up! üòÅ&quot;)
    }
}
</code></pre>
<h2><a class="header" href="#javascript-event-loop-based-task-executor" id="javascript-event-loop-based-task-executor">JavaScript Event Loop-based Task Executor</a></h2>
<p><code>JavaScript Event Loop-based Task Executor</code> is a task executor that cooperates with the JavaScript's event loop. It is provided by <a href="https://github.com/swiftwasm/JavaScriptKit"><code>JavaScriptKit</code></a>, and you need to activate it explicitly by calling a predefined <code>JavaScriptEventLoop.installGlobalExecutor()</code> function (see below for more details).</p>
<p>This executor also has its own <em>event loop</em> that dispatches tasks until no more tasks are enqueued synchronously.
It yields control to the JavaScript side after all pending tasks are dispatched, so JavaScript program can call back to the executed Wasm module.
After a task is resumed by callbacks from JavaScript, the executor starts its event loop again in the next microtask tick.</p>
<p>To enable this executor, you need to use <code>JavaScriptEventLoop</code> module, which is provided as a part of <code>JavaScriptKit</code> package.</p>
<ol start="0">
<li>Ensure that you added <code>JavaScriptKit</code> dependency to your <code>Package.swift</code></li>
<li>Add <code>JavaScriptEventLoop</code> dependency to your targets that use this executor</li>
</ol>
<pre><code class="language-swift">.product(name: &quot;JavaScriptEventLoop&quot;, package: &quot;JavaScriptKit&quot;),
</code></pre>
<ol start="2">
<li>Import <code>JavaScriptEventLoop</code> and call <code>JavaScriptEventLoop.installGlobalExecutor()</code> before spawning any tasks to activate the executor instead of the default cooperative executor.</li>
</ol>
<p>Note that this executor is only available on JavaScript host environment.</p>
<p>See also <a href="https://github.com/swiftwasm/JavaScriptKit/#asyncawait"><code>JavaScriptKit</code> package <code>README</code></a> for more details.</p>
<pre><code class="language-swift">import JavaScriptEventLoop
import JavaScriptKit

JavaScriptEventLoop.installGlobalExecutor()

let document = JSObject.global.document
var asyncButtonElement = document.createElement(&quot;button&quot;)
_ = document.body.appendChild(asyncButtonElement)

asyncButtonElement.innerText = &quot;Fetch Zen&quot;
func printZen() async throws {
    let fetch = JSObject.global.fetch.function!
    let response = try await JSPromise(fetch(&quot;https://api.github.com/zen&quot;).object!)!.value
    let text = try await JSPromise(response.text().object!)!.value
    print(text)
}
asyncButtonElement.onclick = .object(JSClosure { _ in
    Task {
        do {
            try await printZen()
        } catch {
            print(error)
        }
    }

    return .undefined
})
</code></pre>
<h1><a class="header" href="#using-threads-in-webassembly" id="using-threads-in-webassembly">Using threads in WebAssembly</a></h1>
<h2><a class="header" href="#background" id="background">Background</a></h2>
<p>While the WebAssembly spec defines <a href="https://github.com/WebAssembly/threads">atomic operations</a>,
it does not define a way to create threads. This means that WebAssembly modules can't create
threads themselves, and the host environment must provide a way to create threads and run
WebAssembly modules on them.</p>
<h2><a class="header" href="#a-hrefhttpsgithubcomwebassemblywasi-threadswasi-threadsa-proposal" id="a-hrefhttpsgithubcomwebassemblywasi-threadswasi-threadsa-proposal"><a href="https://github.com/WebAssembly/wasi-threads"><code>wasi-threads</code></a> proposal</a></h2>
<p>The WebAssembly System Interface (WASI) had a proposal for adding thread creation APIs to WASI.
The proposal was implemented in several WASI host runtimes, including Wasmtime and wasm-micro-runtime,
but it was <a href="https://github.com/WebAssembly/wasi-threads/issues/48#issuecomment-1696407630">withdrawn in August 2023</a> in favor of <a href="https://github.com/WebAssembly/shared-everything-threads">shared-everything-threads</a> proposal. However, the shared-everything-threads proposal is still in the early stages of development and is not yet available in any WASI host runtime. So, for now, we are employing the <code>wasi-threads</code> ABI in SwiftWasm to provide thread support immediately.</p>
<p>The <code>wasi-threads</code> feature is only available in the <code>wasm32-unknown-wasip1-threads</code> target triple, which is explicitly distinct from the <code>wasm32-unknown-wasi</code> target triple.</p>
<p>The <code>wasm32-unknown-wasip1-threads</code> target triple is only available in the nightly Swift SDK for WebAssembly.</p>
<p>You can run WebAssembly programs built with the <code>wasm32-unknown-wasip1-threads</code> target by using the <code>wasmtime</code> runtime with the <code>--wasi threads</code> flag.
Check <a href="https://github.com/swiftwasm/swift/releases">a recent nightly Swift SDK release</a> and how to install it <a href="getting-started/./setup-snapshot.html">here</a>.</p>
<pre><code class="language-console"># Assume you are using swift-DEVELOPMENT-SNAPSHOT-2024-12-04-a toolchain
$ swift sdk install https://github.com/swiftwasm/swift/releases/download/swift-wasm-DEVELOPMENT-SNAPSHOT-2024-12-05-a/swift-wasm-DEVELOPMENT-SNAPSHOT-2024-12-05-a-wasm32-unknown-wasip1-threads.artifactbundle.zip --checksum 1796ae86f3c90b45d06ee29bb124577aa4135585bbd922430b6d1786f855697d
$ swift build --swift-sdk wasm32-unknown-wasip1-threads
# Enable the `wasi-threads` feature in wasmtime
$ wasmtime --wasi threads .build/debug/Example.wasm
</code></pre>
<p>Note that even with the <code>wasi-threads</code> feature, the default concurrency execution model is still single-threaded as we have not yet ported libdispatch. The <code>wasi-threads</code> feature is only used to provide a low-level <code>pthread</code> API for creating threads.</p>
<h2><a class="header" href="#webworkertaskexecutor---shared-everything-concurrency" id="webworkertaskexecutor---shared-everything-concurrency"><code>WebWorkerTaskExecutor</code> - shared-everything concurrency</a></h2>
<p>We provide <code>WebWorkerTaskExecutor</code>, a <a href="https://github.com/swiftlang/swift-evolution/blob/main/proposals/0417-task-executor-preference.md"><code>TaskExecutor</code></a> implementation that runs <code>Task</code>s in a Web Worker. This allows you to run Swift code concurrently in a Web Worker sharing the same memory space.</p>
<p>This feature is available in the <code>JavaScriptKit</code> package and you need to use <code>wasm32-unkonwn-wasip1-threads</code> target and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer"><code>SharedArrayBuffer</code></a> to use it.</p>
<p>See more details in the following links:</p>
<ul>
<li><a href="https://github.com/swiftwasm/JavaScriptKit/pull/256">Add <code>WebWorkerTaskExecutor</code> ¬∑ Pull Request #256 ¬∑ swiftwasm/JavaScriptKit</a></li>
<li><a href="https://github.com/swiftwasm/JavaScriptKit/tree/main/Examples/Multithreading">JavaScriptKit/Examples/Multithreading at main ¬∑ swiftwasm/JavaScriptKit</a></li>
<li><a href="https://swiftpackageindex.com/swiftwasm/javascriptkit/main/documentation/javascripteventloop/webworkertaskexecutor">WebWorkerTaskExecutor | Documentation</a></li>
</ul>
<h2><a class="header" href="#webworkerkit---shared-nothing-concurrency" id="webworkerkit---shared-nothing-concurrency"><code>WebWorkerKit</code> - shared-nothing concurrency</a></h2>
<p>If you can't use <code>SharedArrayBuffer</code> or want to run Swift code in a separate memory space, you can use <code>WebWorkerKit</code>. <code>WebWorkerKit</code> is a library that provides a way to run Swift Distributed Actors in their own worker &quot;thread&quot; in a Web Worker. It's message-passing based and allows you to run Swift code concurrently in a Web Worker without sharing memory space.</p>
<p>Check the repository for more details: <a href="https://github.com/swiftwasm/WebWorkerKit">swiftwasm/WebWorkerKit: A way of running Swift Distributed Actors in their own worker &quot;thread&quot;</a></p>
<h1><a class="header" href="#testing-your-app" id="testing-your-app">Testing your app</a></h1>
<p>You can write a test suite for your SwiftWasm app or library, or run an existing test suite
written for <code>XCTest</code> if you port existing code to SwiftWasm. Your project has to have a
<code>Package.swift</code> package manifest for this to work. We assume that you use SwiftPM to build your
project and that you have a working package manifest. Please follow <a href="getting-started/./swift-package.html">our SwiftPM guide</a> for new projects.</p>
<h2><a class="header" href="#a-simple-test-case" id="a-simple-test-case">A simple test case</a></h2>
<p>Let's assume you have an <code>Example</code> target in your project that you'd like to test. Your
<code>Package.swift</code> should also have a test suite target with a dependency on the library target. It
would probably look like this:</p>
<pre><code class="language-swift">// swift-tools-version: 5.9

import PackageDescription

let package = Package(
    name: &quot;Example&quot;,
    products: [
        .library(name: &quot;Example&quot;, targets: [&quot;Example&quot;]),
    ],
    targets: [
        .target(name: &quot;Example&quot;),
        .testTarget(name: &quot;ExampleTests&quot;, dependencies: [&quot;Example&quot;]),
    ]
)
</code></pre>
<p>Now you should make sure there's <code>Tests/ExampleTests</code> subdirectory in your project.
If you don't have any files in it yet, create <code>ExampleTests.swift</code> in it:</p>
<pre><code class="language-swift">import Example
import XCTest

final class ExampleTests: XCTestCase {
  func testTrivial() {
    XCTAssertEqual(text, &quot;Hello, world&quot;)
  }
}
</code></pre>
<p>This code assumes that your <code>Example</code> defines some <code>text</code> with <code>&quot;Hello, world&quot;</code> value
for this test to pass. Your test functions should all start with <code>test</code>, please see <a href="https://developer.apple.com/documentation/xctest/defining_test_cases_and_test_methods">XCTest 
documentation</a>
for more details.</p>
<h2><a class="header" href="#building-and-running-the-test-suite-with-swiftpm" id="building-and-running-the-test-suite-with-swiftpm">Building and running the test suite with <code>SwiftPM</code></a></h2>
<p>You can build your test suite by running this command in your terminal:</p>
<pre><code class="language-sh">$ swift build --build-tests --triple wasm32-unknown-wasi
</code></pre>
<p>If you're used to running <code>swift test</code> to run test suites for other Swift platforms, we have to
warn you that this won't work. <code>swift test</code> doesn't know what WebAssembly environment you'd like to 
use to run your tests. Because of this building tests and running them are two separate steps when
using <code>SwiftPM</code>. After your tests are built, you can use a WASI-compatible host such as
<a href="https://wasmtime.dev/">wasmtime</a> to run the test bundle:</p>
<pre><code class="language-sh">$ wasmtime --dir . .build/wasm32-unknown-wasi/debug/ExamplePackageTests.wasm
</code></pre>
<p>(<code>--dir .</code> is used to allow XCTest to find <code>Bundle.main</code> resources placed alongside the executable file.)</p>
<p>As you can see, the produced test binary starts with the name of your package followed by
<code>PackageTests.wasm</code>. It is located in the <code>.build/debug</code> subdirectory, or in the <code>.build/release</code>
subdirectory when you build in release mode.</p>
<h2><a class="header" href="#code-coverage-with-swiftpm" id="code-coverage-with-swiftpm">Code coverage with <code>SwiftPM</code></a></h2>
<blockquote>
<p><strong>Note</strong>: Code coverage support is available only in nightly toolchains for now.</p>
</blockquote>
<p>You can also generate code coverage reports for your test suite. To do this, you need to build your
test suite with the <code>--enable-code-coverage</code> and linker options <code>-Xlinker -lwasi-emulated-getpid</code>:</p>
<pre><code class="language-sh">$ swift build --build-tests --swift-sdk wasm32-unknown-wasi --enable-code-coverage -Xlinker -lwasi-emulated-getpid
</code></pre>
<p>After building your test suite, you can run it with <code>wasmtime</code> as described above. The raw coverage
data will be stored in <code>default.profraw</code> file in the current directory. You can use the <code>llvm-profdata</code>
and <code>llvm-cov</code> tools to generate a human-readable report:</p>
<pre><code class="language-sh">$ wasmtime --dir . .build/wasm32-unknown-wasi/debug/ExamplePackageTests.wasm
$ llvm-profdata merge default.profraw -o default.profdata
$ llvm-cov show .build/wasm32-unknown-wasi/debug/ExamplePackageTests.wasm -instr-profile=default.profdata
# or generate an HTML report
$ llvm-cov show .build/wasm32-unknown-wasi/debug/ExamplePackageTests.wasm -instr-profile=default.profdata --format=html -o coverage
$ open coverage/index.html
</code></pre>
<h2><a class="header" href="#building-and-running-the-test-suite-with-carton" id="building-and-running-the-test-suite-with-carton">Building and running the test suite with <code>carton</code></a></h2>
<p>If you use <a href="https://carton.dev"><code>carton</code></a> to develop and build your app, as described in <a href="getting-started/./browser-app.html">our guide
for browser apps</a>, just run <code>swift run carton test</code> in the
root directory of your package. This will automatically build the test suite and run it with a WASI runtime for you.</p>
<h1><a class="header" href="#configuring-visual-studio-code-with-webassembly-sdk" id="configuring-visual-studio-code-with-webassembly-sdk">Configuring Visual Studio Code with WebAssembly SDK</a></h1>
<p>This guide will help you configure Visual Studio Code (VSCode) to use the Swift SDK for WebAssembly.</p>
<blockquote>
<p><strong>Note</strong>: This guide assumes you have already installed the <a href="getting-started/./setup-snapshot.html">Swift SDK for WebAssembly</a> from the development snapshot release.</p>
</blockquote>
<h2><a class="header" href="#prerequisites" id="prerequisites">Prerequisites</a></h2>
<ul>
<li><a href="https://code.visualstudio.com/">Visual Studio Code</a></li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=sswg.swift-lang">Swift for Visual Studio Code</a></li>
<li><a href="https://swift.org/install">Swift Development Snapshot</a> (<code>swift-DEVELOPMENT-SNAPSHOT-2024-09-04-a</code> or later)</li>
<li><a href="getting-started/./setup-snapshot.html">Swift SDK for WebAssembly</a></li>
</ul>
<h2><a class="header" href="#configure-your-swiftpm-package" id="configure-your-swiftpm-package">Configure your SwiftPM package</a></h2>
<ol>
<li>Open your Swift package in VSCode.</li>
<li>Create a <code>.vscode/settings.json</code> with the following content:</li>
</ol>
<pre><code class="language-json">{
    &quot;swift.path&quot;: &quot;&lt;path-to-swift-toolchain-from-swift.org&gt;/usr/bin&quot;,
}
</code></pre>
<blockquote>
<p><strong>Note</strong>: Replace <code>&lt;path-to-swift-toolchain-from-swift.org&gt;</code> with the path to the development snapshot Swift toolchain you downloaded from <a href="https://www.swift.org/install">swift.org/install</a>.</p>
</blockquote>
<ol start="3">
<li>Create a <code>.sourcekit-lsp/config.json</code> with the following content:</li>
</ol>
<pre><code class="language-json">{
    &quot;swiftPM&quot;: {
        &quot;swiftSDK&quot;: &quot;&lt;Swift SDK id&gt;&quot;
    }
}
</code></pre>
<blockquote>
<p><strong>Note</strong>: Replace <code>&lt;Swift SDK id&gt;</code> with the Swift SDK id you installed using the <code>swift sdk install</code> command. You can find the installed SDK id by running <code>swift sdk list</code>.</p>
</blockquote>
<ol start="4">
<li>Reload the VSCode window by pressing <code>Cmd + Shift + P</code> and selecting <code>Reload Window</code>.</li>
</ol>
<p>That's it! You can now build and auto-complete your Swift package using the Swift SDK for WebAssembly.</p>
<p><img src="getting-started/./vscode-editing.png" alt="" /></p>
<h1><a class="header" href="#debugging" id="debugging">Debugging</a></h1>
<p>Debugging is one of the most important parts of application development. This section describes debugging tools compatible with SwiftWasm.</p>
<p>These tools are DWARF-based, so you need to build your application with DWARF sections enabled.
If you are using <code>carton bundle</code>, you can use the <code>--debug-info</code> flag to enable debugging with optimized application.
If you are using <code>swift build</code>, it is enabled by default.</p>
<h2><a class="header" href="#chrome-devtools" id="chrome-devtools">Chrome DevTools</a></h2>
<p>When you are debugging a web browser application, Chrome DevTools is a good tool to use. It allows you to
put breakpoints and step through at Swift source code level.</p>
<h3><a class="header" href="#official-dwarf-extension" id="official-dwarf-extension">Official DWARF Extension</a></h3>
<p>Please follow the steps below to configure Chrome DevTools for SwiftWasm:</p>
<ol>
<li>Install <a href="https://goo.gle/wasm-debugging-extension"><code>C/C++ DevTools Support (DWARF)</code></a> extension in your Chrome</li>
<li>Enable <code>WebAssembly Debugging: Enable DWARF support</code> in <code>Experiments</code> pane of DevTools settings</li>
</ol>
<p>See <a href="https://developer.chrome.com/blog/wasm-debugging-2020">the DevTools team's official introduction</a> for more details about the extension.</p>
<p><img src="getting-started/./chrome-devtools.png" alt="" /></p>
<p>Note that the function names in the stack trace are mangled. You can demangle them using <code>swift demangle</code> command.</p>
<p>Unfortunately, variable inspection is unavailable since Swift depends on its own mechanisms to do that instead of DWARF's structure type feature. If you need this feature, you can use the enhanced extension below.</p>
<h3><a class="header" href="#enhanced-dwarf-extension-for-swift" id="enhanced-dwarf-extension-for-swift">Enhanced DWARF Extension for Swift</a></h3>
<p>For a better Swift debugging experience, there's also an enhanced version of the DWARF extension specifically for Swift. This extension enables:</p>
<ul>
<li>Breakpoint setting and Swift code inspection</li>
<li>Human-readable call stack frames</li>
<li>Swift variable value inspection</li>
</ul>
<p>To install this enhanced extension:</p>
<ol>
<li>First, uninstall the official &quot;C/C++ DevTools Support (DWARF)&quot; extension if you have it installed</li>
<li>Download the extension ZIP file from <a href="https://github.com/GoodNotes/devtools-frontend/releases/tag/swift-0.2.3.0">GitHub Releases</a></li>
<li>Go to <code>chrome://extensions/</code> and enable &quot;Developer mode&quot;</li>
<li>Drag and drop the downloaded ZIP file into the page</li>
</ol>
<p>When you close and reopen the DevTools window, DevTools will suggest reloading itself to apply settings.</p>
<p>Note: There is a known issue where some JavaScriptKit types like <code>JSObject</code> and <code>JSValue</code> are not shown in pretty format in the variables view.</p>
<p><img src="getting-started/./chrome-devtools-swift.png" alt="" /></p>
<h2><a class="header" href="#a-hrefhttpsgithubcomkateinoigakukunwasminspectwasminspecta" id="a-hrefhttpsgithubcomkateinoigakukunwasminspectwasminspecta"><a href="https://github.com/kateinoigakukun/wasminspect">wasminspect</a></a></h2>
<p><a href="https://github.com/kateinoigakukun/wasminspect">wasminspect</a>
can help in the investigation if the debugged binary does not rely on integration with JavaScript.
We recommend splitting your packages into separate executable targets, most of which shouldn't 
assume the availability of JavaScript to make debugging easier.</p>
<p><img src="https://raw.githubusercontent.com/kateinoigakukun/wasminspect/master/assets/demo.gif" alt="demo" /></p>
<h2><a class="header" href="#a-hrefhttpsgithubcomkateinoigakukunwasm-memprofwasm-memprofa" id="a-hrefhttpsgithubcomkateinoigakukunwasm-memprofwasm-memprofa"><a href="https://github.com/kateinoigakukun/wasm-memprof">wasm-memprof</a></a></h2>
<p>If you are debugging memory leaks, <a href="https://github.com/kateinoigakukun/wasm-memprof">wasm-memprof</a> can help you.
It is a tool to profile memory usage of WebAssembly applications with a few lines of setup code:</p>
<pre><code class="language-javascript">import { WMProf } from &quot;wasm-memprof&quot;;
import { SwiftDemangler } from &quot;wasm-memprof/plugins/swift-demangler.js&quot;;

const swiftDemangler = SwiftDemangler.create();
const WebAssembly = WMProf.wrap(globalThis.WebAssembly, {
  demangler: swiftDemangler.demangle.bind(swiftDemangler),
});
</code></pre>
<p>Check the repository for more details.</p>
<img width="1000" alt="swift-wmprof" src="https://github.com/user-attachments/assets/c1da4582-e721-45b9-9bca-ce320711f72d">
<h1><a class="header" href="#troubleshooting" id="troubleshooting">Troubleshooting</a></h1>
<p>These are some common issues you may run into while using SwiftWasm.</p>
<p>If you are having trouble that is not listed here, try searching for it in the <a href="https://github.com/swiftwasm/swift/issues">SwiftWasm issue tracker</a>.
If you are still having trouble, please file an issue or contact us at <a href="https://discord.gg/ashJW8T8yp">the community Discord server</a>.</p>
<h2><a class="header" href="#runtimeerror-memory-access-out-of-bounds" id="runtimeerror-memory-access-out-of-bounds"><code>RuntimeError: memory access out of bounds</code></a></h2>
<p>If you encounter this error, there are 3 possible causes:</p>
<h3><a class="header" href="#1-you-are-trying-to-access-invalid-memory-in-your-code" id="1-you-are-trying-to-access-invalid-memory-in-your-code">1. You are trying to access invalid memory in your code</a></h3>
<p>In this case, you need to make sure which memory operations are invalid in your code by <code>UnsafePointer</code> or C code.</p>
<h3><a class="header" href="#2-you-missed-program-initialization-defined-in-a-hrefhttpsgithubcomwebassemblywasiblobbac366c8aeb69cacfea6c4c04a503191bf1cede1legacyapplication-abimdwasi-application-abia" id="2-you-missed-program-initialization-defined-in-a-hrefhttpsgithubcomwebassemblywasiblobbac366c8aeb69cacfea6c4c04a503191bf1cede1legacyapplication-abimdwasi-application-abia">2. You missed program initialization defined in <a href="https://github.com/WebAssembly/WASI/blob/bac366c8aeb69cacfea6c4c04a503191bf1cede1/legacy/application-abi.md">WASI Application ABI</a>.</a></h3>
<p>If your application is used as a library, you need to follow <a href="https://github.com/WebAssembly/WASI/blob/bac366c8aeb69cacfea6c4c04a503191bf1cede1/legacy/application-abi.md"><em>WASI reactor ABI</em></a>.</p>
<p>Please make sure that you followed it by reviewing the <a href="getting-started/../examples/exporting-function.html">Exporting function guide</a></p>
<h3><a class="header" href="#3-stack-overflow-is-occurring" id="3-stack-overflow-is-occurring">3. Stack overflow is occurring.</a></h3>
<p>If you are using <code>--stack-first</code> linker option (carton uses it by default), you can face <code>RuntimeError: memory access out of bounds</code> error due to stack overflow.</p>
<p>You have two options to solve this issue:</p>
<ol>
<li>
<p>Avoid recursive calls if possible.</p>
</li>
<li>
<p>Extend the stack size by linker option <code>-z stack-size=&lt;size&gt;</code>. <a href="https://github.com/llvm/llvm-project/blob/fabe915705472e2c06ed1aa9a90620462594e82f/llvm/include/llvm/BinaryFormat/Wasm.h#L32">The default stack size is 64KB</a></p>
<pre><code>swift build --triple wasm32-unknown-wasi -Xlinker -z -Xlinker stack-size=131072
</code></pre>
</li>
<li>
<p>Identify which function consumes a lof of stack space by some tools like <a href="https://github.com/kateinoigakukun/wasm-stack-consumer">wasm-stack-consumer</a></p>
</li>
</ol>
<p>See also: <a href="https://bugs.llvm.org/show_bug.cgi?id=37181">LLVM Bugzilla ‚Äì wasm32: Allow placing the stack before global data</a></p>
<h2><a class="header" href="#fatal-error-stdlibh-file-not-found" id="fatal-error-stdlibh-file-not-found"><code>fatal error: 'stdlib.h' file not found</code></a></h2>
<p>If you encounter this error, please make sure that:</p>
<ul>
<li>You are using SwiftWasm toolchain (if you installed it as a toolchain, not as a Swift SDK)
<ul>
<li>Check <code>which swift</code> and make sure it points to the SwiftWasm toolchain.</li>
</ul>
</li>
<li>You are using the correct target triple:
<ul>
<li><code>--triple wasm32-unknown-wasi --static-swift-stdlib</code> if you installed as a <em>toolchain</em></li>
<li><code>--swift-sdk wasm32-unknown-wasi</code> if you installed as a <em>Swift SDK</em></li>
</ul>
</li>
</ul>
<h2><a class="header" href="#error-missing-external-dependency-usrlibswiftwasistatic-executable-argslnk" id="error-missing-external-dependency-usrlibswiftwasistatic-executable-argslnk"><code>error: missing external dependency '.../usr/lib/swift/wasi/static-executable-args.lnk'</code></a></h2>
<p>You may encounter this error while building with Swift SDK for WebAssembly and <code>swiftc</code> driver command. Unfortunately, Swift SDK does not support building with <code>swiftc</code> command yet, so you need to use <code>swift build</code> Swift Package Manager command instead.</p>
<p>e.g. <code>swift build --swift-sdk &lt;SDK name&gt;</code></p>
<p>See also: <a href="getting-started/./swift-package.html">Compile a SwiftPM package to WebAssembly</a></p>
<h1><a class="header" href="#examples" id="examples">Examples</a></h1>
<p>This section shows you example usage of our toolchain.</p>
<h1><a class="header" href="#importing-a-function-from-host-environments" id="importing-a-function-from-host-environments">Importing a function from host environments</a></h1>
<h2><a class="header" href="#swift-60-or-later" id="swift-60-or-later">Swift 6.0 or later</a></h2>
<p>If you are using Swift 6.0 or later, you can use experimental <code>@_extern(wasm)</code> attribute</p>
<p>Swift 6.0 introduces a new attribute <code>@_extern(wasm)</code> to import a function from the host environment.
To use this experimental feature, you need to enable it in your SwiftPM manifest file:</p>
<pre><code class="language-swift">.executableTarget(
    name: &quot;Example&quot;,
    swiftSettings: [
        .enableExperimentalFeature(&quot;Extern&quot;)
    ]),
</code></pre>
<p>Then, you can import a function from the host environment as follows without using C headers:</p>
<pre><code class="language-swift">@_extern(wasm, module: &quot;env&quot;, name: &quot;add&quot;)
func add(_ a: Int, _ b: Int) -&gt; Int

print(add(2, 2))
</code></pre>
<h2><a class="header" href="#swift-510-or-earlier" id="swift-510-or-earlier">Swift 5.10 or earlier</a></h2>
<p>You can import a function from your host environment using the integration of Swift Package Manager
with C targets. Firstly, you should declare a signature for your function in a C header with an
appropriate <code>__import_name__</code> attribute:</p>
<pre><code class="language-c">__attribute__((__import_name__(&quot;add&quot;)))
extern int add(int lhs, int rhs);
</code></pre>
<p>Here <code>__import_name__</code> specifies the name under which this function will be exposed to Swift code.
Move this C header to a separate target, we'll call it <code>HostFunction</code> in this example. Your
<code>Package.swift</code> manifest for your WebAssembly app would look like this:</p>
<pre><code class="language-swift">// swift-tools-version:5.9
import PackageDescription

let package = Package(
    name: &quot;Example&quot;,
    targets: [
      .target(name: &quot;HostFunction&quot;, dependencies: []),
      .executableTarget(name: &quot;Example&quot;, dependencies: [&quot;HostFunction&quot;]),
    ]
)
</code></pre>
<p>Place this header into the <code>include</code> subdirectory of your <code>HostFunction</code> target directory. You can
then import this host function module into Swift code just as any other module:</p>
<pre><code class="language-swift">import HostFunction

print(add(2, 2))
</code></pre>
<p>Then, you can inject a host function into the produced WebAssembly binary.</p>
<p>Note that we use <code>env</code> as default import module name. You can specify the module name as
<code>__import_module__</code> in your C header. The full list of attributes in the header could look
like <code>__attribute__((__import_module__(&quot;env&quot;),__import_name__(&quot;add&quot;)))</code>.</p>
<pre><code class="language-javascript">// File name: main.mjs
import { WASI, File, OpenFile, ConsoleStdout } from &quot;@bjorn3/browser_wasi_shim&quot;;
import fs from &quot;fs/promises&quot;;

const main = async () =&gt; {

  // Instantiate a new WASI Instance
  // See https://github.com/bjorn3/browser_wasi_shim/ for more detail about constructor options
  let wasi = new WASI([], [],
    [
      new OpenFile(new File([])), // stdin
      ConsoleStdout.lineBuffered(msg =&gt; console.log(`[WASI stdout] ${msg}`)),
      ConsoleStdout.lineBuffered(msg =&gt; console.warn(`[WASI stderr] ${msg}`)),
    ],
    { debug: false }
  );

  const wasmBinary = await fs.readFile(&quot;.build/wasm32-unknown-wasi/debug/Example.wasm&quot;);

  // Instantiate the WebAssembly file
  let { instance } = await WebAssembly.instantiate(wasmBinary, {
    wasi_snapshot_preview1: wasi.wasiImport,
    env: {
      add: (lhs, rhs) =&gt; (lhs + rhs),
    }
  });

  wasi.start(instance);
};

main()
</code></pre>
<p>If you use Go bindings for Wasmer as your host environment, you should check <a href="https://github.com/hassan-shahbazi/swiftwasm-go">an example 
repository</a> from one of our contributors that shows
an integration with an imported host function.</p>
<p>A more streamlined way to import host functions will be implemented in the future version of the
SwiftWasm toolchain.</p>
<h1><a class="header" href="#exporting-function-for-host-environment" id="exporting-function-for-host-environment">Exporting function for host environment</a></h1>
<h2><a class="header" href="#swift-60-or-later-1" id="swift-60-or-later-1">Swift 6.0 or later</a></h2>
<p>If you use Swift 6.0 or later, you can use <code>@_expose(wasm, &quot;add&quot;)</code> and omit the <code>--export</code> linker flag.</p>
<pre><code class="language-swift">// File name: lib.swift
@_expose(wasm, &quot;add&quot;)
@_cdecl(&quot;add&quot;) // This is still required to call the function with C ABI
func add(_ lhs: Int, _ rhs: Int) -&gt; Int {
    return lhs + rhs
}
</code></pre>
<p>Then you can compile the Swift code with the following command without <code>--export</code> linker flag.</p>
<pre><code class="language-bash">$ swiftc \
    -target wasm32-unknown-wasi \
    -parse-as-library \
    lib.swift -o lib.wasm \
    -Xclang-linker -mexec-model=reactor
</code></pre>
<h2><a class="header" href="#swift-510-or-earlier-1" id="swift-510-or-earlier-1">Swift 5.10 or earlier</a></h2>
<p>You can expose a Swift function for host environment using special attribute and linker option.</p>
<pre><code class="language-swift">// File name: lib.swift
@_cdecl(&quot;add&quot;)
func add(_ lhs: Int, _ rhs: Int) -&gt; Int {
    return lhs + rhs
}
</code></pre>
<p>You need to compile the Swift code with linker option <code>--export</code>.</p>
<p>To call the exported function as a library multiple times, you need to:</p>
<ol>
<li>Compile it as a <a href="https://github.com/WebAssembly/WASI/blob/bac366c8aeb69cacfea6c4c04a503191bf1cede1/legacy/application-abi.md"><em>WASI reactor</em> execution model</a>.
The default execution model is <em>command</em>, so you need to pass <code>-mexec-model=reactor</code> to linker.</li>
<li>Call <code>_initialize</code> function before interacting with the instance.</li>
</ol>
<pre><code class="language-bash">$ swiftc \
    -target wasm32-unknown-wasi \
    -parse-as-library \
    lib.swift -o lib.wasm \
    -Xlinker --export=add \
    -Xclang-linker -mexec-model=reactor
</code></pre>
<p>Then, you can use the exported function from host environment.</p>
<pre><code class="language-javascript">// File name: main.mjs
import { WASI, File, OpenFile, ConsoleStdout } from &quot;@bjorn3/browser_wasi_shim&quot;;
import fs from &quot;fs/promises&quot;;

// Instantiate a new WASI Instance
// See https://github.com/bjorn3/browser_wasi_shim/ for more detail about constructor options
let wasi = new WASI([], [],
  [
    new OpenFile(new File([])), // stdin
    ConsoleStdout.lineBuffered(msg =&gt; console.log(`[WASI stdout] ${msg}`)),
    ConsoleStdout.lineBuffered(msg =&gt; console.warn(`[WASI stderr] ${msg}`)),
  ],
  { debug: false }
);

const wasmBinary = await fs.readFile(&quot;lib.wasm&quot;);

// Instantiate the WebAssembly file
const { instance } = await WebAssembly.instantiate(wasmBinary, {
  wasi_snapshot_preview1: wasi.wasiImport,
});
// Initialize the instance by following WASI reactor ABI
wasi.initialize(instance);
// Get the exported function
const addFn = instance.exports.add;
console.log(&quot;2 + 3 = &quot; + addFn(2, 3))
</code></pre>
<p>If you use SwiftPM package, you can omit linker flag using clang's <code>__atribute__</code>. Please see <a href="https://github.com/swiftwasm/JavaScriptKit/pull/91/files">swiftwasm/JavaScriptKit#91</a> for more detail info</p>
<h2><a class="header" href="#example-projects" id="example-projects">Example Projects</a></h2>
<p>You can learn more practical usage of our toolchain in <a href="https://github.com/swiftwasm/awesome-swiftwasm">swiftwasm/awesome-swiftwasm</a></p>
<h1><a class="header" href="#contribution-guide" id="contribution-guide">Contribution Guide</a></h1>
<h2><a class="header" href="#repositories" id="repositories">Repositories</a></h2>
<h3><a class="header" href="#a-hrefhttpsgithubcomswiftwasmswiftwasm-buildswiftwasmswiftwasm-builda" id="a-hrefhttpsgithubcomswiftwasmswiftwasm-buildswiftwasmswiftwasm-builda"><a href="https://github.com/swiftwasm/swiftwasm-build">swiftwasm/swiftwasm-build</a></a></h3>
<p>The main development repository for the SwiftWasm project. It contains the build script and patches for building the Swift compiler and standard library for WebAssembly. See the <a href="https://github.com/swiftwasm/swiftwasm-build/blob/main/README.md">README</a> for more information.</p>
<h3><a class="header" href="#a-hrefhttpsgithubcomswiftwasmicu4c-wasiswiftwasmicu4c-wasia" id="a-hrefhttpsgithubcomswiftwasmicu4c-wasiswiftwasmicu4c-wasia"><a href="https://github.com/swiftwasm/icu4c-wasi">swiftwasm/icu4c-wasi</a></a></h3>
<p>Build script and patches for building ICU project for WebAssembly. <a href="https://github.com/unicode-org/icu/pull/990">The required changes to build 
it</a> were merged to the upstream repository.</p>
<h1><a class="header" href="#how-to-build-toolchain" id="how-to-build-toolchain">How to build toolchain</a></h1>
<p>This document describes how to build the toolchain for WebAssembly.
This is just a quick guide, so if you want to know more about the toolchain, it might be good entry point to read <a href="https://github.com/swiftwasm/swiftwasm-build/blob/main/.github/workflows/build-toolchain.yml">continuous integration scripts</a>.
Or you can ask questions in GitHub issues or SwiftWasm Discord server (see <a href="https://swiftwasm.org">the official website</a> for the link).</p>
<h2><a class="header" href="#1-checkout-the-project-source-code" id="1-checkout-the-project-source-code">1. Checkout the project source code.</a></h2>
<pre><code class="language-sh">$ mkdir swiftwasm-source
$ cd swiftwasm-source
$ git clone https://github.com/swiftwasm/swiftwasm-build.git
$ cd swiftwasm-build
$ ./tools/build/install-build-sdk.sh main
$ ./tools/git-swift-workspace --scheme main
</code></pre>
<h2><a class="header" href="#2-install-required-dependencies" id="2-install-required-dependencies">2. Install required dependencies</a></h2>
<ol>
<li><a href="https://github.com/apple/swift/blob/main/docs/HowToGuides/GettingStarted.md#installing-dependencies">Please follow the upstream instruction</a></li>
<li>(If you want to run test suite) Install <a href="https://wasmtime.dev/"><code>Wasmtime</code></a></li>
</ol>
<p>If you are using macOS, please ensure that you don't have <code>llvm</code> package installed via Homebrew.</p>
<h2><a class="header" href="#3-build-the-toolchain" id="3-build-the-toolchain">3. Build the toolchain</a></h2>
<p><code>./tools/build/build-toolchain.sh</code></p>
<p>This script will build the following components:</p>
<ol>
<li>Swift compiler that can compile Swift code to WebAssembly support</li>
<li>Swift standard library and core libraries for WebAssembly</li>
</ol>
<h2><a class="header" href="#build-on-docker" id="build-on-docker">Build on Docker</a></h2>
<p>You can also build the toolchain on Docker image used in CI.
Note that you have already checked out the source code in <a href="contribution-guide/how-to-build-toolchain.html#1-checkout-the-project-source-code">the previous step</a>.</p>
<pre><code class="language-sh">$ docker volume create oss-swift-package
$ docker run --name swiftwasm-ci-buildbot \
    -dit \
    -w /home/build-user/ \
    -v ./swiftwasm-source:/source \
    -v oss-swift-package:/home/build-user \
    ghcr.io/swiftwasm/swift-ci:main-ubuntu-20.04
$ docker exec swiftwasm-ci-buildbot /bin/bash -lc 'env; cp -r /source/* /home/build-user/; ./swiftwasm-build/tools/build/ci.sh main'
$ docker cp swiftwasm-ci-buildbot:/home/build-user/swift-wasm-DEVELOPMENT-SNAPSHOT-*-ubuntu-20.04.tar.gz .
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
